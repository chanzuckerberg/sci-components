{"version":3,"file":"3618.9fd54632.iframe.bundle.js","mappings":";;AAsCA;AAAA;AAsEA;;AAEA;;AA7BA;AAGA;;;;;;AAQA;;AAoBA;AAqEA;AAGA;AACA;AAqCA;AA3BA;;AAEA;;;;;;;AAOA;;AAEA;;;AAGA;AAcA;AACA;;AAWA;;;;;;;;AAQA;;;AAGA;AAUA;;AAEA;AAgBA;AACA;AAgCA;AACA;AAGA;;;AAGA;;;;;;AACA;;;AAcA;;;AAGA;;;;AAIA;AAgCA;AACA;AACA;;AAEA;AAGA;AAsBA;AACA;;AAEA;;AAIA;;;;;AAOA;;;;;;;;AAUA;;;;;;;AASA;;;;;;AAQA;;;;;;;;AAUA;;;;;;AAQA;;;;;;;;AAUA;;;;;;AAQA;;;;;;AAQA;AAyDA;AACA;;AAEA;AA9CA;AACA;;;AAGA;AACA;;;;;;;AAOA;;;;AAIA;AACA;;AAEA;;;;AAIA;AACA;;AAEA;AAqBA;AAoCA;;;;;AAKA;AAWA;;AAEA;;AAoFA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;;;AAGA;AACA;;;;;AAOA;AACA;AACA;;AAEA;;;;;;;;;;;;AAcA;;;;;;AAQA;;;;;;AAMA;;;;;;;AAOA;AAGA;;;AAKA;;;;AAMA;;;;AAvIA;;;;;;AAQA;;;AAGA;AACA;;AAIA;;;;;AA4HA;;;AAGA;AAEA;AACA;AAEA;AACA;;;;;;AAMA;;;;AAIA;;;;;AAOA;;;;;AAOA;;AAuCA;;;;AAIA;;AAIA;;;;;AAKA;AACA;;AAEA;;;;;;AAMA;;AAEA;AAcA;;;AAKA;;;;;;AAMA;;;AAqBA;;;AAGA;;;;;AA0BA;AACA;AAcA;;AAEA;;AAIA;AACA;;;;;;;AA2BA;AACA;AACA;;;;;;;;;;AAUA;;AAIA;;;AAGA;;;AAcA;;AAEA;;;;AAiBA;AACA;;;AAGA;;AAEA;;;;;;AAmBA;AAUA;AACA;AACA;;AAEA;AAaA;AACA;;;;;;;AASA;AACA;;AAIA;AAaA;;;;;AAKA;AAGA;;;AAeA;AACA;AACA;;AAIA;AAcA;;AAMA;AACA;AAGA;;AC3kCA;AAEA;AAKA;;AAOA;AAEA;AAGA;AAuEA;AACA;;;AAGA;AA2DA;AAGA;;;ACvGA;AACA;ACnGA;AAaA;ACkOA;AACA","sources":["webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/style.ts","webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/components/shared/UnifiedNavItem.tsx","webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/components/style.ts","webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/components/ElevationScroll/index.tsx","webpack://@czi-sds/monorepo/./packages/components/src/core/Tag/style.ts"],"sourcesContent":["/* eslint-disable sonarjs/cognitive-complexity */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport { AppBar, Divider, Drawer, Toolbar, css } from \"@mui/material\";\nimport {\n  CommonThemeProps,\n  fontBodyMediumL,\n  fontBodyL,\n  fontBodyS,\n  fontBodySemiboldL,\n  fontBodySemiboldS,\n  fontBodyMediumS,\n  fontBodyXs,\n  fontHeaderL,\n  fontHeaderM,\n  getCorners,\n  getIconSizes,\n  getSemanticColors,\n  getShadows,\n  getSpaces,\n  getColors,\n  getMode,\n  getTypography,\n} from \"../styles\";\nimport Tag from \"../Tag\";\nimport InputSearch from \"../InputSearch\";\nimport styled from \"@emotion/styled\";\nimport Link from \"../Link\";\nimport Button, { SdsButtonProps, SdsMinimalButtonProps } from \"../Button\";\nimport { SerializedStyles } from \"@emotion/react\";\nimport { IconButtonProps } from \"./NavigationHeader.types\";\nimport Accordion from \"../Accordion\";\n\nexport interface ExtraHeaderProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n  isNarrow?: boolean;\n  sdsStyle?: \"dropdown\" | \"drawer\";\n}\n\nexport const TOOLBAR_HEIGHT = 48;\n\nconst doNotForwardProps = [\n  \"hasInvertedStyle\",\n  \"isNarrow\",\n  \"primaryNavPosition\",\n  \"showSearch\",\n  \"logoLinkComponent\",\n  \"logoLinkProps\",\n  \"defaultUrl\",\n  \"hasDetails\",\n  \"hasIcon\",\n  \"sectionProps\",\n];\n\nexport const StyledTopComponentSlot = styled(\"div\")`\n  position: sticky;\n  top: 0;\n  z-index: 2100;\n`;\n\nexport const StyledAppBar = styled(AppBar, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const colors = getSemanticColors(props);\n\n    return `\n      background-color: ${props.hasInvertedStyle ? colors?.base.backgroundPrimaryDark : colors?.base.backgroundPrimary};\n      background-image: none;\n      max-width: 100%;\n      overflow-x: auto;\n      z-index: 2100;\n    `;\n  }}\n`;\n\nconst NarrowToolbar = (props: ExtraHeaderProps): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    border-bottom: 1px solid\n      ${props.hasInvertedStyle\n        ? semanticColors?.base.dividerOnDark\n        : semanticColors?.base.divider};\n    background-color: ${props.hasInvertedStyle\n      ? semanticColors?.base.backgroundPrimaryDark\n      : semanticColors?.base.backgroundPrimary};\n    background-image: none;\n    box-shadow: none;\n    position: sticky !important;\n    top: 0;\n    justify-content: space-between;\n  `;\n};\n\nexport const StyledToolbar = styled(Toolbar, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    const spaces = getSpaces(props);\n\n    return css`\n      &.MuiToolbar-root {\n        min-height: ${TOOLBAR_HEIGHT}px;\n        max-height: ${TOOLBAR_HEIGHT}px;\n        padding: ${spaces?.s}px ${spaces?.l}px;\n\n        ${isNarrow && NarrowToolbar(props)}\n      }\n    `;\n  }}\n`;\n\nexport const StyledShadowElement = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const shadows = getShadows(props);\n\n    return `\n      box-shadow: ${shadows?.m};\n      height: 10px;\n      display: block;\n      position: fixed;\n      width: 100%;\n      top: 46px;\n      left: 0;\n    `;\n  }}\n`;\n\nexport const StyledShadowCoverElement = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const colors = getSemanticColors(props);\n\n    return `\n      background: ${props.hasInvertedStyle ? colors?.base.backgroundPrimaryDark : colors?.base.backgroundPrimary};\n      height: 10px;\n      display: block;\n      position: absolute;\n      width: 100%;\n      top: 56px;\n      left: 0;\n    `;\n  }}\n`;\n\nexport interface ExtraButtonProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n}\n\nexport const StyledHeaderButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<\n  ExtraButtonProps &\n    (SdsMinimalButtonProps | SdsButtonProps) & { isNarrow?: boolean }\n>`\n  ${(props) => {\n    const { sdsType, hasInvertedStyle, isNarrow } = props;\n\n    const mode = props?.theme?.palette?.mode || \"light\";\n    const semanticColors = getSemanticColors(props);\n\n    const secondaryButtonStyles = `\n      box-shadow: inset 0 0 0 1px ${mode === \"light\" ? \"white\" : semanticColors?.accent?.fillPrimary};\n      color: ${mode === \"light\" ? \"white\" : semanticColors?.accent?.fillPrimary};\n      &:hover {\n        background-color: ${semanticColors?.accent?.fillHover};\n        box-shadow: inset 0 0 0 1px ${semanticColors?.accent?.fillHover};\n        color: ${semanticColors?.base?.textPrimaryOnDark};\n      }\n    `;\n\n    return css`\n      ${sdsType === \"secondary\" && hasInvertedStyle\n        ? secondaryButtonStyles\n        : \"\"}\n      ${isNarrow && fontBodyL(props)}\n    `;\n  }}\n`;\n\nconst invertedNarrowButtonStyles = (\n  props: ExtraButtonProps & (SdsMinimalButtonProps | SdsButtonProps)\n): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    color: ${semanticColors?.base?.textPrimaryOnDark};\n    svg {\n      fill: ${semanticColors?.base?.ornamentPrimaryOnDark};\n    }\n\n    &:hover,\n    &:focus,\n    &:active,\n    &:focus-within {\n      color: ${semanticColors?.base?.textPrimaryOnDark};\n      svg {\n        fill: ${semanticColors?.base?.ornamentPrimaryOnDark};\n      }\n    }\n  `;\n};\n\nexport const StyledNarrowIconButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<\n  ExtraButtonProps &\n    (SdsMinimalButtonProps | SdsButtonProps) & { isNarrow?: boolean }\n>`\n  ${(props) => {\n    const { hasInvertedStyle, isNarrow } = props;\n\n    return css`\n      ${hasInvertedStyle && invertedNarrowButtonStyles(props)}\n      ${isNarrow && fontBodyL(props)}\n    `;\n  }}\n`;\n\nconst invertedWideButtonStyles = (\n  props: ExtraButtonProps & IconButtonProps\n): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    svg {\n      fill: ${semanticColors?.base?.ornamentSecondaryOnDark};\n    }\n\n    &:hover,\n    &:focus,\n    &:active,\n    &:focus-within {\n      svg {\n        fill: ${semanticColors?.base?.ornamentPrimaryOnDark};\n      }\n    }\n  `;\n};\n\nexport const StyledWideIconButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<ExtraButtonProps & IconButtonProps>`\n  ${(props) => {\n    const { hasInvertedStyle } = props;\n\n    return css`\n      ${hasInvertedStyle && invertedWideButtonStyles(props)}\n      margin: 0;\n    `;\n  }}\n`;\n\nexport const StyledLogoLinkWrapper = styled(Link, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  align-items: center;\n  display: flex;\n  text-decoration: none !important;\n\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    return css`\n      width: ${isNarrow ? \"100%\" : \"auto\"};\n    `;\n  }}\n`;\n\nexport const StyledLogoWrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n\nconst NarrowTitleContainer = (): SerializedStyles => {\n  return css`\n    p {\n      margin: 0px;\n      margin-block: 0px;\n    }\n  `;\n};\n\nexport const StyledTitleContainer = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  display: flex;\n  align-items: center;\n\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    const colors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      gap: ${spaces?.l}px;\n      color: ${props.hasInvertedStyle\n        ? colors?.base.textPrimaryOnDark\n        : colors?.base.textPrimary};\n      margin-right: ${spaces?.xxxl}px;\n      width: 100%;\n\n      ${isNarrow && NarrowTitleContainer()}\n    `;\n  }}\n`;\n\nexport const StyledTitleTagWrapper = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const spaces = getSpaces(props);\n\n    return css`\n      display: flex;\n      align-items: center;\n      gap: ${spaces?.xs}px;\n\n      p {\n        ${fontHeaderL(props)}\n        margin: 0;\n        white-space: nowrap;\n      }\n    `;\n  }}\n`;\n\nexport const StyledTag = styled(Tag)`\n  margin: 0;\n`;\n\ninterface StyledPrimaryNavContainerProps extends CommonThemeProps {\n  primaryNavPosition?: \"left\" | \"right\";\n  showSearch?: boolean;\n  isNarrow?: boolean;\n}\n\nexport const StyledPrimaryNavContainer = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  align-items: center;\n  display: flex;\n  flex-grow: 1;\n\n  ${(props: StyledPrimaryNavContainerProps) => {\n    const { showSearch, primaryNavPosition, isNarrow } = props;\n    const spaces = getSpaces(props);\n\n    const primaryNavPositionWithSearch =\n      primaryNavPosition === \"left\" ? \"flex-start\" : \"space-between\";\n    const primaryNavPositionWithoutSearch =\n      primaryNavPosition === \"left\" ? \"flex-start\" : \"flex-end\";\n\n    return css`\n      flex-direction: ${isNarrow ? \"column\" : \"row\"};\n      gap: ${spaces?.xxxl}px;\n      margin-right: ${spaces?.xxxl}px;\n      flex: 1;\n      justify-content: ${showSearch\n        ? primaryNavPositionWithSearch\n        : primaryNavPositionWithoutSearch};\n    `;\n  }}\n`;\n\ninterface ExtraSearchProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n  isNarrow?: boolean;\n}\n\nexport const StyledSearch = styled(InputSearch, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  margin: 0;\n  width: 100%;\n\n  ${(props: ExtraSearchProps) => {\n    const { hasInvertedStyle, isNarrow } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n\n    return css`\n      max-width: ${isNarrow ? \"100%\" : \"320px\"};\n      padding-top: ${isNarrow ? `${spaces?.m}px` : 0};\n      .MuiInputBase-root {\n        color: ${hasInvertedStyle\n          ? semanticColors?.base.textPrimaryOnDark\n          : semanticColors?.base.textPrimary};\n        fieldset {\n          border-color: ${hasInvertedStyle\n            ? semanticColors?.base?.borderPrimaryOnDark\n            : \"\"};\n        }\n\n        .MuiInputBase-input {\n          &::placeholder {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base?.textTertiaryOnDark\n              : semanticColors?.base?.textTertiary};\n            opacity: 1;\n          }\n        }\n\n        .MuiInputAdornment-root {\n          .MuiButtonBase-root:last-of-type {\n            svg {\n              color: ${hasInvertedStyle\n                ? semanticColors?.base?.ornamentSecondaryOnDark\n                : \"\"};\n            }\n          }\n        }\n\n        &:hover {\n          fieldset {\n            border-color: ${hasInvertedStyle\n              ? semanticColors?.base?.borderPrimaryInteractionOnDark\n              : \"\"} !important;\n          }\n\n          .MuiInputAdornment-root {\n            .MuiButtonBase-root:last-of-type {\n              svg {\n                color: ${hasInvertedStyle\n                  ? semanticColors?.base?.ornamentPrimaryOnDark\n                  : \"\"};\n              }\n            }\n          }\n        }\n\n        &.Mui-focused {\n          fieldset {\n            border-color: ${hasInvertedStyle\n              ? semanticColors?.base?.borderPrimaryInteractionOnDark\n              : \"\"} !important;\n          }\n\n          .MuiInputAdornment-root {\n            .MuiButtonBase-root:last-of-type {\n              svg {\n                color: ${hasInvertedStyle\n                  ? semanticColors?.base?.ornamentPrimaryOnDark\n                  : \"\"};\n              }\n            }\n          }\n        }\n\n        &.Mui-disabled {\n          fieldset {\n            border-color: ${hasInvertedStyle\n              ? semanticColors?.base?.borderPrimaryDisabledOnDark\n              : \"\"} !important;\n          }\n\n          .MuiInputAdornment-root {\n            .MuiButtonBase-root:last-of-type {\n              svg {\n                color: ${hasInvertedStyle\n                  ? semanticColors?.base?.ornamentDisabledOnDark\n                  : \"\"};\n              }\n            }\n          }\n        }\n      }\n    `;\n  }}\n`;\n\nconst NarrowButtonStyles = (props: ExtraHeaderProps): SerializedStyles => {\n  const spaces = getSpaces(props);\n  const sizes = getIconSizes(props);\n  const colors = getSemanticColors(props);\n\n  const backgroundColor = props.hasInvertedStyle\n    ? colors?.base.backgroundPrimaryDark\n    : colors?.base.backgroundPrimary;\n\n  return css`\n    background: ${backgroundColor};\n    gap: ${spaces?.l}px;\n    flex-direction: column-reverse;\n    margin-left: 0;\n    margin-top: ${spaces?.xl}px;\n    padding: ${spaces?.xl}px 0;\n    position: sticky;\n    bottom: 0;\n\n    &::before {\n      content: \"\";\n      position: absolute;\n      height: ${spaces?.xxxl}px;\n      width: 100%;\n      background: linear-gradient(\n        to top,\n        ${backgroundColor} 0%,\n        ${backgroundColor}00 100%\n      );\n      top: -${spaces?.xxxl}px;\n    }\n\n    .MuiButton-icon .MuiSvgIcon-root {\n      width: ${sizes?.l.width}px;\n      height: ${sizes?.l.height}px;\n    }\n  `;\n};\n\nexport const StyledButtonSection = styled(\"section\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  display: flex;\n  align-items: center;\n  z-index: 100;\n\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    const spaces = getSpaces(props);\n\n    return css`\n      gap: ${spaces?.m}px;\n      margin-left: ${spaces?.xxxl}px;\n\n      ${isNarrow && NarrowButtonStyles(props)}\n    `;\n  }}\n`;\n\nexport const StyledDrawer = styled(Drawer, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\", \"topOffset\"].includes(prop),\n})<ExtraHeaderProps & { topOffset?: number }>`\n  ${(props: ExtraHeaderProps & { topOffset?: number }) => {\n    const colors = getSemanticColors(props);\n    const { topOffset = 0 } = props;\n\n    return `\n      .MuiDrawer-paper {\n        background: ${props.hasInvertedStyle ? colors?.base.backgroundPrimaryDark : colors?.base.backgroundPrimary};\n        box-shadow: none;\n        background-image: none;\n        width: 100%;\n        display: flex;\n        flex-direction: column;\n        top: ${topOffset + TOOLBAR_HEIGHT}px;\n        height: calc(100% - ${topOffset + TOOLBAR_HEIGHT}px);\n        justify-content: space-between;\n      }\n    `;\n  }}\n`;\n\nexport const StyledDrawerContent = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps>`\n  ${(props: ExtraHeaderProps) => {\n    const spaces = getSpaces(props);\n\n    return css`\n      padding: 0 ${spaces?.l}px;\n      flex-grow: 1;\n      display: flex;\n      flex-direction: column;\n      justify-content: space-between;\n    `;\n  }}\n`;\n\nexport const StyledNarrowButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: ExtraButtonProps & IconButtonProps) => {\n    const { hasInvertedStyle } = props;\n\n    return css`\n      ${hasInvertedStyle && invertedWideButtonStyles(props)}\n      margin: 0;\n    `;\n  }}\n`;\n\nexport interface DrawerAccordionStylesProps extends CommonThemeProps {\n  sdsStyle?: \"dropdown\" | \"drawer\";\n  hasInvertedStyle?: boolean;\n}\n\nconst DrawerAccordionStyles = (\n  props: DrawerAccordionStylesProps\n): SerializedStyles => {\n  const { hasInvertedStyle } = props;\n\n  const semanticColors = getSemanticColors(props);\n  const spaces = getSpaces(props);\n  const textOpenColor = hasInvertedStyle\n    ? semanticColors?.base.textPrimaryOnDark\n    : semanticColors?.base.textPrimary;\n\n  return css`\n    border-radius: 0;\n\n    &:hover {\n      background-color: ${hasInvertedStyle\n        ? semanticColors?.base?.backgroundPrimaryDark\n        : semanticColors?.base?.backgroundPrimary};\n    }\n\n    &[aria-expanded=\"true\"] {\n      position: sticky;\n      border-radius: 0;\n      top: ${spaces?.s}px;\n      z-index: 11;\n      backdrop-filter: blur(0px);\n      color: ${textOpenColor};\n      background-color: ${hasInvertedStyle\n        ? semanticColors?.base?.backgroundPrimaryDark\n        : semanticColors?.base?.backgroundPrimary};\n    }\n  `;\n};\n\nexport const StyledAccordion = styled(Accordion, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  padding: 0 !important;\n  width: 100%;\n  min-width: unset;\n\n  .MuiAccordionSummary-content {\n    ${fontBodyMediumL}\n  }\n\n  .MuiAccordionDetails-root .MuiButtonBase-root .primary-text {\n    ${fontBodyS}\n  }\n\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle, sdsStyle = \"dropdown\" } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n\n    const textDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.textSecondaryOnDark\n      : semanticColors?.base.textSecondary;\n\n    const textOpenColor = hasInvertedStyle\n      ? semanticColors?.base.textPrimaryOnDark\n      : semanticColors?.base.textPrimary;\n\n    const ChevronDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.ornamentSecondaryOnDark\n      : semanticColors?.base.ornamentSecondary;\n\n    const ChevronOpenColor = hasInvertedStyle\n      ? semanticColors?.base?.ornamentSecondaryInteractionOnDark\n      : semanticColors?.base.ornamentSecondaryInteraction;\n\n    return css`\n      & > .MuiButtonBase-root {\n        padding: ${spaces?.s}px ${spaces?.l}px !important;\n        border-radius: ${corners?.l}px;\n        color: ${textDefaultColor};\n\n        svg {\n          color: ${ChevronDefaultColor};\n        }\n\n        &[aria-expanded=\"true\"] {\n          position: sticky;\n          border-radius: ${corners?.l}px;\n          top: calc(48px + ${spaces?.s}px);\n          z-index: 11;\n          backdrop-filter: blur(8px);\n          color: ${textOpenColor};\n          background-color: ${hasInvertedStyle\n            ? semanticColors?.base?.fillPressedOnDark\n            : semanticColors?.base?.fillPressed};\n\n          &::before {\n            content: \"\";\n            position: absolute;\n            top: -${spaces?.s}px;\n            left: -${spaces?.l ?? 0 * 2}px;\n            right: -${spaces?.l ?? 0 * 2}px;\n            bottom: 0;\n            background-color: ${hasInvertedStyle\n              ? semanticColors?.base?.backgroundPrimaryDark\n              : semanticColors?.base?.backgroundPrimary};\n          }\n\n          &::after {\n            content: \"\";\n            position: absolute;\n            top: 100%;\n            left: 0;\n            width: 100%;\n            height: 10px;\n            background-image: linear-gradient(\n              to bottom,\n              ${hasInvertedStyle\n                ? semanticColors?.base?.backgroundPrimaryDark\n                : semanticColors?.base?.backgroundPrimary},\n              transparent\n            );\n          }\n\n          .MuiAccordionSummary-content {\n            ${fontBodySemiboldL(props)}\n            position: relative;\n            z-index: 12;\n          }\n\n          svg {\n            color: ${ChevronOpenColor} !important;\n          }\n        }\n\n        &:hover {\n          width: 100%;\n          box-shadow: none;\n          background: ${hasInvertedStyle\n            ? semanticColors?.base.fillInteractionOnDark\n            : semanticColors?.base.fillInteraction};\n          color: ${hasInvertedStyle\n            ? semanticColors?.base.textPrimaryOnDark\n            : semanticColors?.base.textPrimary};\n\n          svg {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base?.ornamentSecondaryInteractionOnDark\n              : semanticColors?.base.ornamentSecondaryInteraction} !important;\n          }\n        }\n\n        ${sdsStyle === \"drawer\" && DrawerAccordionStyles(props)}\n      }\n\n      .MuiCollapse-root .MuiAccordionDetails-root {\n        padding: 0;\n        margin-top: ${sdsStyle === \"drawer\" ? spaces?.s : spaces?.xxs}px;\n\n        .MuiButtonBase-root {\n          ${sdsStyle === \"drawer\"\n            ? css`\n                padding: ${spaces?.s}px 0;\n              `\n            : css`\n                padding: ${spaces?.s}px ${spaces?.m}px ${spaces?.s}px\n                  ${spaces?.xl}px !important;\n              `}\n\n          width: 100%;\n\n          svg {\n            color: ${semanticColors?.accent?.ornament};\n          }\n\n          .primary-text {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base.textSecondaryOnDark\n              : semanticColors?.base.textSecondary} !important;\n          }\n\n          &:hover {\n            .primary-text {\n              color: ${hasInvertedStyle\n                ? semanticColors?.base.textPrimaryOnDark\n                : semanticColors?.base.textPrimary} !important;\n            }\n          }\n        }\n      }\n    `;\n  }}\n`;\n\ninterface StyledSectionDividerProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n}\n\nexport const StyledSectionDivider = styled(Divider, {\n  shouldForwardProp: (prop) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop as string),\n})`\n  ${(props: StyledSectionDividerProps) => {\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return `\n      margin: ${spaces?.s}px 0;\n      border-color: ${\n        props.hasInvertedStyle\n          ? semanticColors?.base.dividerOnDark\n          : semanticColors?.base.divider\n      };\n    `;\n  }}\n`;\n\n// Hover Drawer Components for sdsStyle=\"drawer\"\nexport const StyledMegaMenuDrawer = styled(Drawer, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\", \"topOffset\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps & { topOffset?: number }) => {\n    const { hasInvertedStyle, topOffset = 0 } = props;\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      pointer-events: none;\n      top: ${topOffset}px;\n      z-index: 2000;\n\n      .MuiDrawer-paper {\n        background-color: ${hasInvertedStyle\n          ? semanticColors?.base.backgroundPrimaryDark\n          : semanticColors?.base.backgroundPrimary};\n        height: auto;\n        max-height: calc(100vh - ${topOffset}px);\n        overflow: visible;\n        pointer-events: auto;\n        box-shadow: 0 8px 8px 0 rgba(0, 0, 0, 0.1);\n        background-image: none;\n        padding: ${spaces?.xl ? spaces?.xl + 48 : 48}px ${spaces?.xl}px\n          ${spaces?.xxxl}px;\n        transform: translateY(48px);\n        top: ${topOffset}px;\n      }\n\n      .MuiBackdrop-root {\n        background-color: rgba(0, 0, 0, 0);\n        backdrop-filter: blur(2px);\n        top: ${topOffset}px;\n      }\n    `;\n  }}\n`;\n\nexport const StyledMegaMenuContent = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle } = props;\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      background-color: ${hasInvertedStyle\n        ? semanticColors?.base.backgroundPrimaryDark\n        : semanticColors?.base.backgroundPrimary};\n      display: flex;\n      flex-wrap: wrap;\n      gap: ${spaces?.xxxl}px;\n      width: 100%;\n      max-width: 1200px;\n      margin: 0 auto;\n      justify-content: center;\n      transition: opacity 150ms ease-in-out;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerColumn = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\", \"totalColumns\"].includes(prop),\n})<ExtraHeaderProps & { totalColumns?: number }>`\n  ${(props: ExtraHeaderProps & { totalColumns?: number }) => {\n    const spaces = getSpaces(props);\n    const { totalColumns = 1 } = props;\n\n    // Calculate equal width for all columns based on total columns\n    // Account for gaps between columns\n    const columnsPerRow = totalColumns > 4 ? 4 : totalColumns;\n    const gapCount = columnsPerRow - 1;\n    const columnWidth = `calc((100% - (${gapCount} * ${spaces?.xxxl}px)) / ${columnsPerRow})`;\n\n    return css`\n      display: flex;\n      flex-direction: column;\n      flex: 0 0 ${columnWidth};\n      min-width: 240px;\n      max-width: 400px;\n    `;\n  }}\n`;\n\nexport const StyledContentWrapper = styled(\"div\")<\n  CommonThemeProps & { needsHeaderPadding: boolean }\n>`\n  ${(props) => {\n    const { needsHeaderPadding } = props;\n\n    const spaces = getSpaces(props);\n    const typography = getTypography(props);\n\n    // Calculate padding to match header height + margin\n    // fontHeaderM has line-height of 22px, plus margin-bottom of m (12px)\n    const headerHeight = parseInt(\n      (typography?.wideStyles?.header?.semibold?.m?.lineHeight as string) ||\n        \"22px\"\n    );\n    const headerMargin = spaces?.m || 12;\n\n    return css`\n      & > *:last-child {\n        margin-bottom: 0;\n      }\n\n      padding-top: ${needsHeaderPadding ? headerHeight + headerMargin : 0}px;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerColumnHeader = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle } = props;\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      ${fontHeaderM(props)}\n      font-weight: 600;\n      color: ${hasInvertedStyle\n        ? semanticColors?.base.textSecondaryOnDark\n        : semanticColors?.base.textSecondary};\n      padding: 0 0 0 56px;\n      margin-bottom: ${spaces?.m}px;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItem = styled(\n  Button as unknown as React.ComponentType<\n    Partial<SdsMinimalButtonProps> &\n      ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }\n  >,\n  {\n    shouldForwardProp: (prop: string) =>\n      ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n  }\n)<ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }) => {\n    const { hasInvertedStyle, hasDetails } = props;\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      border: none;\n      outline: none;\n      background: transparent;\n      box-shadow: none;\n      justify-content: flex-start;\n      text-align: left;\n      padding: ${hasDetails ? spaces?.l : spaces?.m}px ${spaces?.l}px;\n      margin-bottom: ${hasDetails ? spaces?.s : 0}px;\n      border-radius: ${corners?.xl}px;\n      min-height: auto;\n      width: 100%;\n      white-space: wrap;\n\n      &:hover {\n        border: none;\n        outline: none;\n        box-shadow: none;\n        cursor: pointer;\n        background: ${hasInvertedStyle\n          ? semanticColors?.base.fillInteractionOnDark\n          : semanticColors?.base.fillInteraction};\n        svg {\n          color: ${semanticColors?.accent?.ornament};\n        }\n      }\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemContent = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps & { hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasDetails?: boolean }) => {\n    const spaces = getSpaces(props);\n\n    return css`\n      display: flex;\n      align-items: center;\n      gap: ${spaces?.l}px;\n      width: 100%;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemIcon = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }) => {\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n    const { hasDetails } = props;\n\n    return css`\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 0 ${hasDetails ? 0 : spaces?.xxs}px;\n      color: ${semanticColors?.accent?.ornament};\n\n      svg {\n        color: ${semanticColors?.accent?.ornament};\n      }\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemText = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${() => {\n    return css`\n      display: flex;\n      flex-direction: column;\n      gap: 2px;\n      flex: 1;\n      min-width: 0;\n    `;\n  }}\n`;\n\nexport const EmptyIcon = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps & { hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasDetails?: boolean }) => {\n    const { hasDetails } = props;\n    const spaces = getSpaces(props);\n    const iconSize = getIconSizes(props);\n\n    return css`\n      width: ${hasDetails ? iconSize?.l?.width : iconSize?.s?.width}px;\n      height: ${hasDetails ? iconSize?.l?.height : iconSize?.s?.height}px;\n      padding: 0 ${hasDetails ? 0 : spaces?.xxs}px;\n      box-sizing: content-box;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemTitle = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps & { hasDetails?: boolean }) => {\n    const { hasInvertedStyle, hasDetails } = props;\n    const semanticColors = getSemanticColors(props);\n\n    return css`\n      ${hasDetails ? fontBodySemiboldS(props) : fontBodyMediumS(props)}\n      color: ${hasInvertedStyle\n        ? semanticColors?.base.textPrimaryOnDark\n        : semanticColors?.base.textPrimary};\n\n      display: -webkit-box;\n      -webkit-box-orient: vertical;\n      -webkit-line-clamp: 2;\n      overflow: hidden;\n\n      ${StyledHoverDrawerItem}:hover & {\n        color: ${hasInvertedStyle\n          ? semanticColors?.base.textPrimaryOnDark\n          : semanticColors?.base.textPrimary};\n      }\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemDetails = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle } = props;\n    const semanticColors = getSemanticColors(props);\n\n    return css`\n      ${fontBodyXs(props)}\n      display: -webkit-box;\n      -webkit-box-orient: vertical;\n      -webkit-line-clamp: 3;\n      overflow: hidden;\n      color: ${hasInvertedStyle\n        ? semanticColors?.base.textSecondaryOnDark\n        : semanticColors?.base.textSecondary};\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerActions = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: CommonThemeProps & { isNarrow?: boolean }) => {\n    const spaces = getSpaces(props);\n    const { isNarrow } = props;\n\n    return css`\n      display: flex;\n      flex-direction: row;\n      gap: ${spaces?.xs}px;\n      margin-top: ${spaces?.l}px;\n      padding-left: ${isNarrow\n        ? `calc(${spaces?.l}px + ${spaces?.m}px)`\n        : `calc(${spaces?.xxxl}px + ${spaces?.xs}px)`};\n      flex-wrap: wrap;\n    `;\n  }}\n`;\n\nexport const StyledButton = styled(Button)<ExtraButtonProps>`\n  ${(props) => {\n    const { hasInvertedStyle } = props;\n\n    const colors = getColors(props);\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n    const mode = getMode(props);\n\n    return css`\n      background-color: ${hasInvertedStyle\n        ? colors?.gray[\"700\"]\n        : mode === \"dark\"\n          ? colors?.gray[\"100\"]\n          : colors?.gray[\"200\"]};\n      width: fit-content !important;\n      padding: ${spaces?.s}px ${spaces?.m}px !important;\n      color: ${hasInvertedStyle\n        ? semanticColors?.base?.textPrimaryOnDark\n        : semanticColors?.base?.textPrimary};\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerContainer = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  position: relative;\n`;\n","/* eslint-disable sonarjs/cognitive-complexity */\nimport styled from \"@emotion/styled\";\nimport { css, SerializedStyles } from \"@emotion/react\";\nimport {\n  getSemanticColors,\n  getSpaces,\n  getCorners,\n  fontBodyMediumS,\n  fontBodySemiboldS,\n  fontBodyMediumL,\n  fontBodySemiboldL,\n  CommonThemeProps,\n} from \"src/core/styles\";\nimport Button, { SdsMinimalButtonProps } from \"src/core/Button\";\n\ninterface UnifiedNavItemProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n  isNarrow?: boolean;\n  /**\n   * Whether the nav item is active (for primary nav) or open (for secondary nav)\n   * These mean the same thing - the item is currently selected/showing dropdown\n   */\n  active?: boolean;\n  itemType?: \"dropdown\" | \"text\";\n  innerSdsStyle?: \"drawer\" | \"dropdown\";\n  /**\n   * Navigation variant determines styling differences between primary and secondary nav\n   * - primary: Used for main navigation items (with StyledLabel)\n   * - secondary: Used for secondary navigation items (simpler styling)\n   */\n  navVariant: \"primary\" | \"secondary\";\n}\n\nconst doNotForwardProps = [\n  \"active\",\n  \"hasInvertedStyle\",\n  \"isNarrow\",\n  \"hasSection\",\n  \"innerSdsStyle\",\n  \"defaultUrl\",\n  \"hasDetails\",\n  \"hasIcon\",\n  \"sectionProps\",\n  \"navVariant\",\n  \"itemType\",\n];\n\nconst NarrowNavItemStyles = (props: UnifiedNavItemProps): SerializedStyles => {\n  const { active, hasInvertedStyle, innerSdsStyle, navVariant } = props;\n\n  const spaces = getSpaces(props);\n  const semanticColors = getSemanticColors(props);\n  const corners = getCorners(props);\n\n  const ChevronHoverColor = hasInvertedStyle\n    ? semanticColors?.base?.ornamentSecondaryInteractionOnDark\n    : semanticColors?.base?.ornamentSecondaryInteraction;\n\n  return css`\n    ${active ? fontBodySemiboldL(props) : fontBodyMediumL(props)}\n    border-radius: ${corners?.l}px;\n    padding: ${spaces?.s}px\n      ${navVariant === \"primary\" ? spaces?.l : spaces?.m}px;\n    ${navVariant === \"primary\" ? \"justify-content: start;\" : \"\"}\n    ${innerSdsStyle === \"drawer\"\n      ? css`\n          background-color: transparent !important;\n        `\n      : css`\n          background-color: ${active\n            ? hasInvertedStyle\n              ? semanticColors?.base?.fillPressedOnDark\n              : semanticColors?.base?.fillPressed\n            : \"transparent\"};\n        `}\n    width: 100%;\n\n    &:hover {\n      ${innerSdsStyle === \"drawer\"\n        ? css`\n            background: transparent !important;\n          `\n        : css`\n            background: ${hasInvertedStyle\n              ? semanticColors?.base.fillInteractionOnDark\n              : semanticColors?.base.fillInteraction};\n          `}\n      box-shadow: none;\n\n      ${navVariant === \"primary\" && StyledLabel} {\n        color: ${hasInvertedStyle\n          ? semanticColors?.base.textPrimaryOnDark\n          : semanticColors?.base.textPrimary};\n      }\n\n      svg {\n        color: ${ChevronHoverColor} !important;\n      }\n    }\n  `;\n};\n\nexport const UnifiedNavItem = styled(\n  Button as unknown as React.ComponentType<\n    Partial<SdsMinimalButtonProps> & UnifiedNavItemProps\n  >,\n  {\n    shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n  }\n)`\n  display: flex;\n  align-items: center;\n  min-width: fit-content;\n  border: none;\n  background: transparent;\n\n  ${(props: UnifiedNavItemProps) => {\n    const { hasInvertedStyle, isNarrow, active, navVariant } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n\n    const textDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.textSecondaryOnDark\n      : semanticColors?.base.textSecondary;\n\n    const textActiveColor = hasInvertedStyle\n      ? semanticColors?.base.textPrimaryOnDark\n      : semanticColors?.base.textPrimary;\n\n    const ChevronDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.ornamentSecondaryOnDark\n      : semanticColors?.base.ornamentSecondary;\n\n    const ChevronHoverColor = hasInvertedStyle\n      ? semanticColors?.base?.ornamentSecondaryInteractionOnDark\n      : semanticColors?.base.ornamentSecondaryInteraction;\n\n    const ChevronOpenColor = hasInvertedStyle\n      ? semanticColors?.base.ornamentSecondaryInteractionOnDark\n      : semanticColors?.base.ornamentSecondaryInteraction;\n\n    return [\n      navVariant === \"secondary\" &&\n        (active ? fontBodySemiboldS(props) : fontBodyMediumS(props)),\n      css`\n        padding: ${spaces?.xxxs}px ${spaces?.m}px;\n        border-radius: ${corners?.l}px;\n        background-color: ${active\n          ? hasInvertedStyle\n            ? semanticColors?.base?.fillPressedOnDark\n            : semanticColors?.base?.fillPressed\n          : \"transparent\"};\n\n        ${navVariant === \"secondary\"\n          ? css`\n              gap: ${spaces?.xs}px;\n              color: ${active ? textActiveColor : textDefaultColor};\n              justify-content: flex-start;\n              width: fit-content;\n            `\n          : \"\"}\n\n        svg {\n          color: ${active ? ChevronOpenColor : ChevronDefaultColor};\n        }\n\n        &:hover {\n          background: ${hasInvertedStyle\n            ? semanticColors?.base.fillInteractionOnDark\n            : semanticColors?.base.fillInteraction} !important;\n          box-shadow: none;\n\n          ${navVariant === \"primary\" && StyledLabel} {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base.textPrimaryOnDark\n              : semanticColors?.base.textPrimary};\n          }\n\n          svg {\n            color: ${ChevronHoverColor} !important;\n          }\n        }\n\n        ${isNarrow && NarrowNavItemStyles(props)}\n      `,\n    ];\n  }}\n`;\n\n// StyledLabel for primary nav items (secondary nav doesn't use this)\nexport const StyledLabel = styled(\"span\", {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: UnifiedNavItemProps) => {\n    const { hasInvertedStyle, active, isNarrow } = props;\n\n    const spaces = getSpaces(props);\n    const colors = getSemanticColors(props);\n\n    const activeColor = hasInvertedStyle\n      ? colors?.base.textPrimaryOnDark\n      : colors?.base.textPrimary;\n\n    const inactiveColor = hasInvertedStyle\n      ? colors?.base.textSecondaryOnDark\n      : colors?.base.textSecondary;\n\n    return [\n      active ? fontBodySemiboldS(props) : fontBodyMediumS(props),\n      css`\n        position: relative;\n        display: flex;\n        align-items: center;\n        gap: ${spaces?.xs}px;\n        color: ${active ? activeColor : inactiveColor};\n\n        ${isNarrow &&\n        css`\n          ${active ? fontBodySemiboldL(props) : fontBodyMediumL(props)}\n        `}\n      `,\n    ];\n  }}\n`;\n","import styled from \"@emotion/styled\";\nimport {\n  CommonThemeProps,\n  fontBodyMediumL,\n  fontBodyMediumS,\n  fontBodySemiboldM,\n  fontBodySemiboldL,\n  fontBodySemiboldS,\n  fontCapsXxxxs,\n  getSemanticColors,\n  getSpaces,\n  getCorners,\n} from \"src/core/styles\";\nimport { css, SerializedStyles } from \"@emotion/react\";\nimport ListSubheader from \"src/core/List/components/ListSubheader\";\nimport { Divider } from \"@mui/material\";\nimport { ExtraHeaderProps } from \"../style\";\nimport { AccordionDetails } from \"src/core/Accordion\";\n\nconst doNotForwardProps = [\n  \"isNarrow\",\n  \"hasSection\",\n  \"hasInvertedStyle\",\n  \"sectionProps\",\n  \"sdsStyle\",\n];\n\nconst NarrowStyledSection = (props: CommonThemeProps): SerializedStyles => {\n  const spaces = getSpaces(props);\n\n  return css`\n    align-items: start;\n    flex-direction: column;\n    margin-top: ${spaces?.m}px;\n  `;\n};\n\nexport const StyledSection = styled(\"section\", {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  display: flex;\n  align-items: center;\n\n  ${(props: CommonThemeProps & { isNarrow?: boolean }) => {\n    const { isNarrow } = props;\n    const spaces = getSpaces(props);\n\n    return css`\n      column-gap: ${spaces?.m}px;\n      row-gap: ${spaces?.s}px;\n      ${isNarrow && NarrowStyledSection(props)}\n    `;\n  }}\n`;\n\nexport const StyledSectionHeader = styled(ListSubheader, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow, hasInvertedStyle, sdsStyle } = props;\n\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    function getBackgroundColor() {\n      if (isNarrow) {\n        return hasInvertedStyle\n          ? semanticColors?.base.backgroundPrimaryDark\n          : semanticColors?.base.backgroundPrimary;\n      }\n\n      return semanticColors?.base?.surfacePrimary;\n    }\n\n    function getTextColor() {\n      if (isNarrow) {\n        return hasInvertedStyle\n          ? semanticColors?.base.textSecondaryOnDark\n          : semanticColors?.base.textSecondary;\n      }\n\n      return semanticColors?.base?.textSecondary;\n    }\n\n    if (sdsStyle === \"drawer\") {\n      return css`\n        ${fontBodySemiboldM(props)}\n        top: 0;\n        color: ${getTextColor()} !important;\n        background-color: transparent;\n        padding: 0;\n        margin-bottom: ${spaces?.xxs}px !important;\n      `;\n    }\n\n    return css`\n      &.MuiListSubheader-root {\n        ${fontCapsXxxxs(props)}\n        top: 0;\n        color: ${getTextColor()};\n        background-color: ${getBackgroundColor()};\n        padding: ${spaces?.xxs}px ${isNarrow ? spaces?.xl : spaces?.xs}px;\n        margin-bottom: 0;\n      }\n    `;\n  }}\n`;\n\nexport const StyledAccordionDetails = styled(AccordionDetails, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: CommonThemeProps & { sdsStyle?: \"dropdown\" | \"drawer\" }) => {\n    const { sdsStyle } = props;\n    const spaces = getSpaces(props);\n\n    return css`\n      ${sdsStyle === \"drawer\" &&\n      css`\n        display: flex;\n        flex-direction: column;\n        gap: ${spaces?.m}px;\n      `}\n    `;\n  }}\n`;\n\nexport const StyledAccordionSection = styled(\"div\", {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(\n    props: CommonThemeProps & {\n      sdsStyle?: \"dropdown\" | \"drawer\";\n      hasInvertedStyle?: boolean;\n    }\n  ) => {\n    const { sdsStyle, hasInvertedStyle } = props;\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n\n    if (sdsStyle === \"drawer\") {\n      return css`\n        border-radius: ${corners?.xl}px;\n        padding: ${spaces?.l}px;\n        background-color: ${hasInvertedStyle\n          ? semanticColors?.base?.backgroundSecondaryDark\n          : semanticColors?.base?.backgroundSecondary};\n      `;\n    }\n\n    return css`\n      padding: 0;\n    `;\n  }}\n`;\n\ninterface StyledDividerProps extends CommonThemeProps {\n  hasSection?: boolean;\n  isNarrow?: boolean;\n  hasInvertedStyle?: boolean;\n}\n\nexport const StyledDivider = styled(Divider, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: StyledDividerProps) => {\n    const { hasSection, isNarrow, hasInvertedStyle } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n\n    // Calculate margin based on section and narrow state\n    const getMarginBottom = () => {\n      return hasSection ? spaces?.s : spaces?.xxs;\n    };\n\n    const getBorderColor = () => {\n      if (isNarrow) {\n        return hasInvertedStyle\n          ? semanticColors?.base?.dividerOnDark\n          : semanticColors?.base?.divider;\n      }\n\n      return semanticColors?.base?.divider;\n    };\n\n    return css`\n      &.MuiDivider-root {\n        position: relative;\n        margin: 0 0 ${getMarginBottom()}px;\n        border-bottom: solid 1px ${getBorderColor()};\n        padding-bottom: ${spaces?.xxs}px;\n      }\n    `;\n  }}\n`;\n\nexport const StyledLabelTextWrapper = styled(\"div\")`\n  ${(props: CommonThemeProps & { active?: boolean; isNarrow?: boolean }) => {\n    const { active, isNarrow } = props;\n\n    return [\n      isNarrow\n        ? active\n          ? fontBodySemiboldL(props)\n          : fontBodyMediumL(props)\n        : active\n          ? fontBodySemiboldS(props)\n          : fontBodyMediumS(props),\n      css`\n        position: absolute;\n      `,\n    ];\n  }}\n`;\n\nexport const StyledLabelTextWrapperShadow = styled(\"div\")`\n  ${(props: CommonThemeProps & { active?: boolean; isNarrow?: boolean }) => {\n    const { isNarrow } = props;\n    return css`\n      ${isNarrow ? fontBodySemiboldL(props) : fontBodySemiboldS(props)}\n      visibility: hidden;\n      opacity: 0;\n    `;\n  }}\n`;\n","import { AppBarProps, css, useScrollTrigger, useTheme } from \"@mui/material\";\nimport React from \"react\";\nimport { CommonThemeProps } from \"src/core/styles\";\n\ninterface ElevationScrollProps extends CommonThemeProps, AppBarProps {\n  window?: () => Window;\n  children?: React.ReactElement;\n  shouldElevate?: boolean;\n}\n\nfunction ElevationScroll(elevationProps: ElevationScrollProps) {\n  const { children, window, shouldElevate = true } = elevationProps;\n  const theme = useTheme();\n  const mode = theme.palette.mode;\n\n  const trigger = useScrollTrigger({\n    disableHysteresis: true,\n    target: window ? window() : undefined,\n    threshold: 0,\n  });\n\n  const darkModeStyles = css`\n    border-bottom: 1px solid ${theme.palette?.sds?.base?.borderSecondary};\n  `;\n\n  /**\n   * (masoudmanson): Elevation is set to 10 when the user scrolls and 0 otherwise.\n   * MUI's elevation range is 0-24, but in the SDS theme, we have mapped:\n   * - shadow.none to 0\n   * - shadow.S to values 1-8\n   * - shadow.M to values 9-16\n   * - shadow.L to values 17-24\n   *\n   * Since the navigation requires a shadow.M drop shadow based on the design system,\n   * any elevation value between 9 and 16 will produce the same effect.\n   */\n  return children\n    ? React.cloneElement(children, {\n        elevation: trigger && shouldElevate ? 14 : 0,\n        sx:\n          trigger && shouldElevate\n            ? {\n                ...(elevationProps.sx || {}),\n                ...(mode === \"dark\" && darkModeStyles),\n              }\n            : undefined,\n      })\n    : null;\n}\n\nexport default ElevationScroll;\n","import { css, SerializedStyles } from \"@emotion/react\";\nimport { alpha, Chip, darken } from \"@mui/material\";\nimport styled from \"@emotion/styled\";\nimport {\n  CommonThemeProps,\n  defaultTheme,\n  focusVisibleA11yStyle,\n  fontBodyXs,\n  fontBodyXxxs,\n  fontHeaderXs,\n  getCorners,\n  getIconSizes,\n  getSemanticColors,\n  getSpaces,\n  IntentColor,\n  SDSPalette,\n  SDSTheme,\n} from \"src/core/styles\";\n\nexport type SdsTagColorType =\n  | \"info\"\n  | \"positive\"\n  | \"notice\"\n  | \"negative\"\n  | \"neutral\"\n  | \"beta\"\n  | [string, string]\n  | [string, string, string];\n\ninterface ExtraSmallTagProps extends CommonThemeProps {\n  hover?: boolean;\n  sdsType?: \"primary\" | \"secondary\";\n  sdsStyle?: \"square\" | \"rounded\";\n  sdsSize?: \"s\";\n  tagColor?: SdsTagColorType;\n  icon?: JSX.Element;\n}\ninterface ExtraLargeTagProps extends CommonThemeProps {\n  hover?: boolean;\n  sdsType?: \"primary\" | \"secondary\";\n  sdsStyle?: \"square\" | \"rounded\";\n  sdsSize?: \"l\";\n  tagColor?: SdsTagColorType;\n  icon: JSX.Element;\n}\nexport type ExtraTagProps = ExtraSmallTagProps | ExtraLargeTagProps;\n\nconst tagSizeS = (props: ExtraTagProps): SerializedStyles => {\n  const spaces = getSpaces(props);\n  const iconSizes = getIconSizes(props);\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    height: unset;\n\n    .MuiChip-label {\n      ${fontBodyXxxs(props)}\n      padding: 0;\n    }\n\n    .MuiSvgIcon-root {\n      height: ${iconSizes?.xs.height}px;\n      width: ${iconSizes?.xs.width}px;\n      margin: 0 ${spaces?.xxs}px 0 0;\n    }\n\n    .MuiChip-deleteIcon {\n      ${fontHeaderXs(props)}\n      color: ${semanticColors?.base?.ornamentPrimaryInverse};\n      margin: 0 0 0 ${spaces?.xxs}px;\n      height: ${iconSizes?.s.height}px;\n      width: ${iconSizes?.s.width}px;\n    }\n  `;\n};\n\nconst tagSizeL = (props: ExtraTagProps): SerializedStyles => {\n  const spaces = getSpaces(props);\n  const iconSizes = getIconSizes(props);\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    height: unset;\n\n    .MuiChip-label {\n      ${fontBodyXs(props)}\n      padding: 0;\n    }\n\n    .MuiSvgIcon-root {\n      height: ${iconSizes?.l.height}px;\n      width: ${iconSizes?.l.width}px;\n      margin: 0 ${spaces?.xxs}px 0 0px;\n    }\n\n    .MuiChip-deleteIcon {\n      ${fontHeaderXs(props)}\n      color: ${semanticColors?.base?.ornamentPrimaryInverse};\n      margin: 0 0 0 ${spaces?.xxs}px;\n      height: ${iconSizes?.s.height}px;\n      width: ${iconSizes?.s.width}px;\n    }\n  `;\n};\n\nconst rounded = (props: ExtraTagProps): SerializedStyles => {\n  const corners = getCorners(props);\n  const spaces = getSpaces(props);\n\n  const { sdsSize = \"s\", icon } = props;\n\n  const topBottomPadding =\n    sdsSize === \"s\" ? spaces?.xxxs : icon ? spaces?.xxs : spaces?.xs;\n  const rightPadding = sdsSize === \"l\" && icon ? spaces?.s : spaces?.xs;\n\n  return css`\n    border-radius: ${corners?.rounded}px;\n    padding: ${topBottomPadding}px ${rightPadding}px ${topBottomPadding}px\n      ${spaces?.xs}px;\n\n    &:after {\n      content: \"\";\n      border-radius: ${corners?.rounded}px;\n    }\n  `;\n};\n\nconst square = (props: ExtraTagProps): SerializedStyles => {\n  const corners = getCorners(props);\n  const spaces = getSpaces(props);\n\n  const { sdsSize = \"s\", icon } = props;\n\n  const topBottomPadding =\n    sdsSize === \"s\" ? spaces?.xxxs : icon ? spaces?.xxs : spaces?.xs;\n\n  return css`\n    border-radius: ${corners?.m}px;\n    padding: ${topBottomPadding}px ${spaces?.xs}px;\n\n    &:after {\n      content: \"\";\n      border-radius: ${corners?.m}px;\n    }\n  `;\n};\n\nconst withHover = (props: ExtraTagProps): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    &:hover {\n      cursor: pointer;\n    }\n\n    &:hover,\n    &:focus-visible {\n      color: ${semanticColors?.base?.textPrimaryInverse};\n    }\n  `;\n};\n\nconst primary = (props: ExtraTagProps): SerializedStyles | undefined => {\n  return createTypeCss(props, \"primary\");\n};\n\nconst secondary = (props: ExtraTagProps): SerializedStyles | undefined => {\n  return createTypeCss(props, \"secondary\");\n};\n\nfunction generatePrimaryTagColors(\n  intent: Extract<SdsTagColorType, string> | null,\n  colors: string[],\n  semanticColors: SDSPalette | null\n) {\n  const effectiveIntent = intent || \"neutral\";\n  const intentColors = semanticColors?.[effectiveIntent];\n  const hasCustomColors = colors.length >= 2;\n\n  return {\n    background: hasCustomColors ? colors[1] : intentColors?.fillPrimary,\n    backgroundClicked: hasCustomColors\n      ? darken(colors[1], 0.3)\n      : intentColors?.fillPressed,\n    backgroundHover: hasCustomColors\n      ? darken(colors[1], 0.15)\n      : intentColors?.fillHover,\n    iconColor: hasCustomColors\n      ? colors[2]\n      : semanticColors?.base?.ornamentOnFill,\n    label: colors.length > 0 ? colors[0] : semanticColors?.base?.textOnFill,\n    borderColor: alpha(semanticColors?.neutral.border || \"#000\", 0.6),\n  };\n}\n\nfunction getSecondaryBorderColor(\n  effectiveIntent: string,\n  theme: SDSTheme,\n  intentColors?: IntentColor\n) {\n  if (!theme || !theme.palette)\n    return alpha(intentColors?.border || \"#000\", 0.6);\n  if (effectiveIntent === \"negative\" && theme.palette.mode === \"dark\")\n    return alpha(intentColors?.border || \"#000\", 0.65);\n  if (effectiveIntent === \"notice\" && theme.palette.mode === \"light\")\n    return alpha(intentColors?.border || \"#000\", 0.85);\n  return alpha(intentColors?.border || \"#000\", 0.6);\n}\n\nfunction generateSecondaryTagColors(\n  intent: Extract<SdsTagColorType, string> | null,\n  colors: string[],\n  semanticColors: SDSPalette | null,\n  theme: SDSTheme = defaultTheme\n) {\n  const effectiveIntent = intent || \"neutral\";\n  const intentColors = semanticColors?.[effectiveIntent];\n  const hasCustomColors = colors.length >= 2;\n\n  return {\n    background: hasCustomColors ? colors[1] : intentColors?.fillSecondary,\n    backgroundClicked: hasCustomColors\n      ? darken(colors[1], 0.3)\n      : intentColors?.fillPressed,\n    backgroundHover: hasCustomColors\n      ? darken(colors[1], 0.15)\n      : intentColors?.fillHover,\n    iconColor: hasCustomColors ? colors[2] : intentColors?.ornament,\n    label: colors.length > 0 ? colors[0] : intentColors?.text,\n    borderColor: hasCustomColors\n      ? alpha(colors[1], 0.6)\n      : getSecondaryBorderColor(effectiveIntent, theme, intentColors),\n  };\n}\n\nfunction createTypeCss(\n  props: ExtraTagProps,\n  type: NonNullable<ExtraTagProps[\"sdsType\"]>\n): SerializedStyles | undefined {\n  const semanticColors = getSemanticColors(props);\n\n  const intent = typeof props.tagColor === \"string\" ? props.tagColor : null;\n  const colors = Array.isArray(props.tagColor) ? [...props.tagColor] : [];\n\n  const typeToColors = {\n    primary: generatePrimaryTagColors(intent, colors, semanticColors),\n    secondary: generateSecondaryTagColors(\n      intent,\n      colors,\n      semanticColors,\n      props.theme\n    ),\n  };\n\n  const typeColors = typeToColors[type];\n\n  return css`\n    ${focusVisibleA11yStyle(props)}\n\n    ${type === \"secondary\" &&\n    css`\n      box-shadow: inset 0 0 0 1px ${typeColors.borderColor};\n    `}\n    background-color: ${typeColors.background};\n    position: relative;\n\n    .MuiChip-label {\n      color: ${typeColors.label};\n    }\n\n    svg {\n      fill: ${typeColors.iconColor};\n    }\n\n    &:hover,\n    &:active {\n      box-shadow: none;\n      .MuiChip-label {\n        color: ${semanticColors?.base?.textPrimaryInverse};\n      }\n\n      svg {\n        fill: ${semanticColors?.base?.ornamentPrimaryInverse};\n      }\n    }\n\n    &:hover {\n      background-color: ${typeColors.backgroundHover};\n    }\n\n    &:active {\n      background-color: ${typeColors.backgroundClicked};\n    }\n\n    &.Mui-focusVisible {\n      background-color: ${typeColors.backgroundHover};\n    }\n  `;\n}\n\nconst typeToCss = {\n  primary,\n  secondary,\n};\n\nconst doNotForwardProps = [\n  \"sdsType\",\n  \"sdsStyle\",\n  \"sdsSize\",\n  \"tagColor\",\n  \"hover\",\n];\n\nexport const StyledTag = styled(Chip, {\n  shouldForwardProp: (prop) => !doNotForwardProps.includes(prop as string),\n})`\n  border: none;\n\n  ${(props: ExtraTagProps) => {\n    const { hover = true, sdsType, sdsStyle, sdsSize = \"s\" } = props;\n\n    const isRounded = sdsStyle === \"rounded\";\n    const type = sdsType || \"primary\";\n\n    return css`\n      ${sdsSize === \"l\" ? tagSizeL(props) : tagSizeS(props)}\n      ${typeToCss[type](props)}\n      ${isRounded ? rounded(props) : square(props)}\n      ${hover ? withHover(props) : `pointer-events: none;`}\n    `;\n  }}\n`;\n"],"names":[],"sourceRoot":""}