{"version":3,"file":"9042.1a6235d4.iframe.bundle.js","mappings":";;;;AA0GA;;AAEA;;AA7BA;AAGA;;;;;;AAQA;;AAoBA;AAqEA;AAGA;AACA;AAqCA;AA3BA;;AAEA;;;;;;;AAOA;;AAEA;;;AAGA;AAcA;AACA;;AAWA;;;;;;;;AAQA;;;AAGA;AAUA;;AAEA;AAgBA;AACA;AAgCA;AACA;AAGA;;;AAGA;;;;;;AACA;;;AAcA;;;AAGA;;;;AAIA;AAgCA;AACA;AACA;;AAEA;AAGA;AAsBA;AACA;;AAEA;;AAIA;;;;;AAOA;;;;;;;;AAUA;;;;;;;AASA;;;;;;AAQA;;;;;;;;AAUA;;;;;;AAQA;;;;;;;;AAUA;;;;;;AAQA;;;;;;AAQA;AAyDA;AACA;;AAEA;AA9CA;AACA;;;AAGA;AACA;;;;;;;AAOA;;;;AAIA;AACA;;AAEA;;;;AAIA;AACA;;AAEA;AAqBA;AAoCA;;;;;AAKA;AAWA;;AAEA;;AAoFA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;;;AAGA;AACA;;;;;AAOA;AACA;AACA;;AAEA;;;;;;;;;;;;AAcA;;;;;;AAQA;;;;;;AAMA;;;;;;;AAOA;AAGA;;;AAKA;;;;AAMA;;;;AAvIA;;;;;;AAQA;;;AAGA;AACA;;AAIA;;;;;AA4HA;;;AAGA;AAEA;AACA;AAEA;AACA;;;;;;AAMA;;;;AAIA;;;;;AAOA;;;;;AAOA;;AAuCA;;;AAGA;;AAIA;;;;;AAKA;AACA;;AAEA;;;;;;AAMA;;AAEA;AAcA;;;AAKA;;;;;;AAMA;;;AAqBA;;;AAGA;;;;;AA0BA;AACA;AAcA;;AAEA;;AAIA;AACA;;;;;;;AA2BA;AACA;AACA;;;;;;;;;;AAUA;;AAIA;;;AAGA;;;AAcA;;AAEA;;;;AAiBA;AACA;;;AAGA;;AAEA;;;;;;AAmBA;AAUA;AACA;AACA;;AAEA;AAaA;AACA;;;;;;;AASA;AACA;;AAIA;AAaA;;;;;AAKA;AAGA;;;AAeA;AACA;AACA;;AAIA;AAcA;;AAMA;AACA;AAGA;;ACtlCA;AAEA;AAKA;;AAOA;AAEA;AAGA;;;ACgDA;AACA;ACnGA;AAaA","sources":["webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/style.ts","webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/components/NavigationHeaderPrimaryNav/style.ts","webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/components/style.ts","webpack://@czi-sds/monorepo/./packages/components/src/core/NavigationHeader/components/ElevationScroll/index.tsx"],"sourcesContent":["/* eslint-disable sonarjs/cognitive-complexity */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport { AppBar, Divider, Drawer, Toolbar, css } from \"@mui/material\";\nimport {\n  CommonThemeProps,\n  fontBodyMediumL,\n  fontBodyL,\n  fontBodyS,\n  fontBodySemiboldL,\n  fontBodySemiboldS,\n  fontBodyMediumS,\n  fontBodyXs,\n  fontHeaderL,\n  fontHeaderM,\n  getCorners,\n  getIconSizes,\n  getSemanticColors,\n  getShadows,\n  getSpaces,\n  getColors,\n  getMode,\n  getTypography,\n} from \"../styles\";\nimport Tag from \"../Tag\";\nimport InputSearch from \"../InputSearch\";\nimport styled from \"@emotion/styled\";\nimport Link from \"../Link\";\nimport Button, { SdsButtonProps, SdsMinimalButtonProps } from \"../Button\";\nimport { SerializedStyles } from \"@emotion/react\";\nimport { IconButtonProps } from \"./NavigationHeader.types\";\nimport Accordion from \"../Accordion\";\n\nexport interface ExtraHeaderProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n  isNarrow?: boolean;\n  sdsStyle?: \"dropdown\" | \"drawer\";\n}\n\nconst doNotForwardProps = [\n  \"hasInvertedStyle\",\n  \"isNarrow\",\n  \"primaryNavPosition\",\n  \"showSearch\",\n  \"logoLinkComponent\",\n  \"logoLinkProps\",\n  \"defaultUrl\",\n  \"hasDetails\",\n  \"hasIcon\",\n  \"sectionProps\",\n];\n\nexport const StyledTopComponentSlot = styled(\"div\")`\n  position: sticky;\n  top: 0;\n  z-index: 1300;\n`;\n\nexport const StyledAppBar = styled(AppBar, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const colors = getSemanticColors(props);\n\n    return `\n      background-color: ${props.hasInvertedStyle ? colors?.base.backgroundPrimaryDark : colors?.base.backgroundPrimary};\n      background-image: none;\n      max-width: 100%;\n      overflow-x: auto;\n      z-index: ${props.theme?.zIndex?.drawer ? props.theme.zIndex.drawer + 10 : 1210};\n    `;\n  }}\n`;\n\nconst NarrowToolbar = (props: ExtraHeaderProps): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    border-bottom: 1px solid\n      ${props.hasInvertedStyle\n        ? semanticColors?.base.dividerOnDark\n        : semanticColors?.base.divider};\n    background-color: ${props.hasInvertedStyle\n      ? semanticColors?.base.backgroundPrimaryDark\n      : semanticColors?.base.backgroundPrimary};\n    background-image: none;\n    box-shadow: none;\n    position: sticky !important;\n    top: 0;\n    justify-content: space-between;\n  `;\n};\n\nexport const StyledToolbar = styled(Toolbar, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    const spaces = getSpaces(props);\n\n    return css`\n      &.MuiToolbar-root {\n        min-height: 48px;\n        max-height: 48px;\n        padding: ${spaces?.s}px ${spaces?.l}px;\n\n        ${isNarrow && NarrowToolbar(props)}\n      }\n    `;\n  }}\n`;\n\nexport const StyledShadowElement = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const shadows = getShadows(props);\n\n    return `\n      box-shadow: ${shadows?.m};\n      height: 10px;\n      display: block;\n      position: fixed;\n      width: 100%;\n      top: 46px;\n      left: 0;\n    `;\n  }}\n`;\n\nexport const StyledShadowCoverElement = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const colors = getSemanticColors(props);\n\n    return `\n      background: ${props.hasInvertedStyle ? colors?.base.backgroundPrimaryDark : colors?.base.backgroundPrimary};\n      height: 10px;\n      display: block;\n      position: absolute;\n      width: 100%;\n      top: 56px;\n      left: 0;\n    `;\n  }}\n`;\n\nexport interface ExtraButtonProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n}\n\nexport const StyledHeaderButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<\n  ExtraButtonProps &\n    (SdsMinimalButtonProps | SdsButtonProps) & { isNarrow?: boolean }\n>`\n  ${(props) => {\n    const { sdsType, hasInvertedStyle, isNarrow } = props;\n\n    const mode = props?.theme?.palette?.mode || \"light\";\n    const semanticColors = getSemanticColors(props);\n\n    const secondaryButtonStyles = `\n      box-shadow: inset 0 0 0 1px ${mode === \"light\" ? \"white\" : semanticColors?.accent?.fillPrimary};\n      color: ${mode === \"light\" ? \"white\" : semanticColors?.accent?.fillPrimary};\n      &:hover {\n        background-color: ${semanticColors?.accent?.fillHover};\n        box-shadow: inset 0 0 0 1px ${semanticColors?.accent?.fillHover};\n        color: ${semanticColors?.base?.textPrimaryOnDark};\n      }\n    `;\n\n    return css`\n      ${sdsType === \"secondary\" && hasInvertedStyle\n        ? secondaryButtonStyles\n        : \"\"}\n      ${isNarrow && fontBodyL(props)}\n    `;\n  }}\n`;\n\nconst invertedNarrowButtonStyles = (\n  props: ExtraButtonProps & (SdsMinimalButtonProps | SdsButtonProps)\n): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    color: ${semanticColors?.base?.textPrimaryOnDark};\n    svg {\n      fill: ${semanticColors?.base?.ornamentPrimaryOnDark};\n    }\n\n    &:hover,\n    &:focus,\n    &:active,\n    &:focus-within {\n      color: ${semanticColors?.base?.textPrimaryOnDark};\n      svg {\n        fill: ${semanticColors?.base?.ornamentPrimaryOnDark};\n      }\n    }\n  `;\n};\n\nexport const StyledNarrowIconButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<\n  ExtraButtonProps &\n    (SdsMinimalButtonProps | SdsButtonProps) & { isNarrow?: boolean }\n>`\n  ${(props) => {\n    const { hasInvertedStyle, isNarrow } = props;\n\n    return css`\n      ${hasInvertedStyle && invertedNarrowButtonStyles(props)}\n      ${isNarrow && fontBodyL(props)}\n    `;\n  }}\n`;\n\nconst invertedWideButtonStyles = (\n  props: ExtraButtonProps & IconButtonProps\n): SerializedStyles => {\n  const semanticColors = getSemanticColors(props);\n\n  return css`\n    svg {\n      fill: ${semanticColors?.base?.ornamentSecondaryOnDark};\n    }\n\n    &:hover,\n    &:focus,\n    &:active,\n    &:focus-within {\n      svg {\n        fill: ${semanticColors?.base?.ornamentPrimaryOnDark};\n      }\n    }\n  `;\n};\n\nexport const StyledWideIconButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<ExtraButtonProps & IconButtonProps>`\n  ${(props) => {\n    const { hasInvertedStyle } = props;\n\n    return css`\n      ${hasInvertedStyle && invertedWideButtonStyles(props)}\n      margin: 0;\n    `;\n  }}\n`;\n\nexport const StyledLogoLinkWrapper = styled(Link, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  align-items: center;\n  display: flex;\n  text-decoration: none !important;\n\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    return css`\n      width: ${isNarrow ? \"100%\" : \"auto\"};\n    `;\n  }}\n`;\n\nexport const StyledLogoWrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n\nconst NarrowTitleContainer = (): SerializedStyles => {\n  return css`\n    p {\n      margin: 0px;\n      margin-block: 0px;\n    }\n  `;\n};\n\nexport const StyledTitleContainer = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  display: flex;\n  align-items: center;\n\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    const colors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      gap: ${spaces?.l}px;\n      color: ${props.hasInvertedStyle\n        ? colors?.base.textPrimaryOnDark\n        : colors?.base.textPrimary};\n      margin-right: ${spaces?.xxl}px;\n      width: 100%;\n\n      ${isNarrow && NarrowTitleContainer()}\n    `;\n  }}\n`;\n\nexport const StyledTitleTagWrapper = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const spaces = getSpaces(props);\n\n    return css`\n      display: flex;\n      align-items: center;\n      gap: ${spaces?.xs}px;\n\n      p {\n        ${fontHeaderL(props)}\n        margin: 0;\n        white-space: nowrap;\n      }\n    `;\n  }}\n`;\n\nexport const StyledTag = styled(Tag)`\n  margin: 0;\n`;\n\ninterface StyledPrimaryNavContainerProps extends CommonThemeProps {\n  primaryNavPosition?: \"left\" | \"right\";\n  showSearch?: boolean;\n  isNarrow?: boolean;\n}\n\nexport const StyledPrimaryNavContainer = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  align-items: center;\n  display: flex;\n  flex-grow: 1;\n\n  ${(props: StyledPrimaryNavContainerProps) => {\n    const { showSearch, primaryNavPosition, isNarrow } = props;\n    const spaces = getSpaces(props);\n\n    const primaryNavPositionWithSearch =\n      primaryNavPosition === \"left\" ? \"flex-start\" : \"space-between\";\n    const primaryNavPositionWithoutSearch =\n      primaryNavPosition === \"left\" ? \"flex-start\" : \"flex-end\";\n\n    return css`\n      flex-direction: ${isNarrow ? \"column\" : \"row\"};\n      gap: ${spaces?.xxl}px;\n      margin-right: ${spaces?.xxl}px;\n      flex: 1;\n      justify-content: ${showSearch\n        ? primaryNavPositionWithSearch\n        : primaryNavPositionWithoutSearch};\n    `;\n  }}\n`;\n\ninterface ExtraSearchProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n  isNarrow?: boolean;\n}\n\nexport const StyledSearch = styled(InputSearch, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  margin: 0;\n  width: 100%;\n\n  ${(props: ExtraSearchProps) => {\n    const { hasInvertedStyle, isNarrow } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n\n    return css`\n      max-width: ${isNarrow ? \"100%\" : \"320px\"};\n      padding-top: ${isNarrow ? `${spaces?.m}px` : 0};\n      .MuiInputBase-root {\n        color: ${hasInvertedStyle\n          ? semanticColors?.base.textPrimaryOnDark\n          : semanticColors?.base.textPrimary};\n        fieldset {\n          border-color: ${hasInvertedStyle\n            ? semanticColors?.base?.borderPrimaryOnDark\n            : \"\"};\n        }\n\n        .MuiInputBase-input {\n          &::placeholder {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base?.textTertiaryOnDark\n              : semanticColors?.base?.textTertiary};\n            opacity: 1;\n          }\n        }\n\n        .MuiInputAdornment-root {\n          .MuiButtonBase-root:last-of-type {\n            svg {\n              color: ${hasInvertedStyle\n                ? semanticColors?.base?.ornamentSecondaryOnDark\n                : \"\"};\n            }\n          }\n        }\n\n        &:hover {\n          fieldset {\n            border-color: ${hasInvertedStyle\n              ? semanticColors?.base?.borderPrimaryHoverOnDark\n              : \"\"} !important;\n          }\n\n          .MuiInputAdornment-root {\n            .MuiButtonBase-root:last-of-type {\n              svg {\n                color: ${hasInvertedStyle\n                  ? semanticColors?.base?.ornamentPrimaryOnDark\n                  : \"\"};\n              }\n            }\n          }\n        }\n\n        &.Mui-focused {\n          fieldset {\n            border-color: ${hasInvertedStyle\n              ? semanticColors?.base?.borderPrimaryPressedOnDark\n              : \"\"} !important;\n          }\n\n          .MuiInputAdornment-root {\n            .MuiButtonBase-root:last-of-type {\n              svg {\n                color: ${hasInvertedStyle\n                  ? semanticColors?.base?.ornamentPrimaryOnDark\n                  : \"\"};\n              }\n            }\n          }\n        }\n\n        &.Mui-disabled {\n          fieldset {\n            border-color: ${hasInvertedStyle\n              ? semanticColors?.base?.borderPrimaryDisabledOnDark\n              : \"\"} !important;\n          }\n\n          .MuiInputAdornment-root {\n            .MuiButtonBase-root:last-of-type {\n              svg {\n                color: ${hasInvertedStyle\n                  ? semanticColors?.base?.ornamentDisabledOnDark\n                  : \"\"};\n              }\n            }\n          }\n        }\n      }\n    `;\n  }}\n`;\n\nconst NarrowButtonStyles = (props: ExtraHeaderProps): SerializedStyles => {\n  const spaces = getSpaces(props);\n  const sizes = getIconSizes(props);\n  const colors = getSemanticColors(props);\n\n  const backgroundColor = props.hasInvertedStyle\n    ? colors?.base.backgroundPrimaryDark\n    : colors?.base.backgroundPrimary;\n\n  return css`\n    background: ${backgroundColor};\n    gap: ${spaces?.l}px;\n    flex-direction: column-reverse;\n    margin-left: 0;\n    margin-top: ${spaces?.xl}px;\n    padding: ${spaces?.xl}px 0;\n    position: sticky;\n    bottom: 0;\n\n    &::before {\n      content: \"\";\n      position: absolute;\n      height: ${spaces?.xxl}px;\n      width: 100%;\n      background: linear-gradient(\n        to top,\n        ${backgroundColor} 0%,\n        ${backgroundColor}00 100%\n      );\n      top: -${spaces?.xxl}px;\n    }\n\n    .MuiButton-icon .MuiSvgIcon-root {\n      width: ${sizes?.l.width}px;\n      height: ${sizes?.l.height}px;\n    }\n  `;\n};\n\nexport const StyledButtonSection = styled(\"section\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  display: flex;\n  align-items: center;\n  z-index: 100;\n\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow } = props;\n\n    const spaces = getSpaces(props);\n\n    return css`\n      gap: ${spaces?.m}px;\n      margin-left: ${spaces?.xxl}px;\n\n      ${isNarrow && NarrowButtonStyles(props)}\n    `;\n  }}\n`;\n\nexport const StyledDrawer = styled(Drawer, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\", \"topOffset\"].includes(prop),\n})<ExtraHeaderProps & { topOffset?: number }>`\n  ${(props: ExtraHeaderProps & { topOffset?: number }) => {\n    const colors = getSemanticColors(props);\n    const { topOffset = 0 } = props;\n\n    return `\n      .MuiDrawer-paper {\n        background: ${props.hasInvertedStyle ? colors?.base.backgroundPrimaryDark : colors?.base.backgroundPrimary};\n        box-shadow: none;\n        background-image: none;\n        width: 100%;\n        display: flex;\n        flex-direction: column;\n        top: ${topOffset}px;\n        height: calc(100% - ${topOffset}px);\n        justify-content: space-between;\n      }\n    `;\n  }}\n`;\n\nexport const StyledDrawerContent = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps>`\n  ${(props: ExtraHeaderProps) => {\n    const spaces = getSpaces(props);\n\n    return css`\n      padding: 0 ${spaces?.l}px;\n      flex-grow: 1;\n      display: flex;\n      flex-direction: column;\n      justify-content: space-between;\n    `;\n  }}\n`;\n\nexport const StyledNarrowButton = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: ExtraButtonProps & IconButtonProps) => {\n    const { hasInvertedStyle } = props;\n\n    return css`\n      ${hasInvertedStyle && invertedWideButtonStyles(props)}\n      margin: 0;\n    `;\n  }}\n`;\n\nexport interface DrawerAccordionStylesProps extends CommonThemeProps {\n  sdsStyle?: \"dropdown\" | \"drawer\";\n  hasInvertedStyle?: boolean;\n}\n\nconst DrawerAccordionStyles = (\n  props: DrawerAccordionStylesProps\n): SerializedStyles => {\n  const { hasInvertedStyle } = props;\n\n  const semanticColors = getSemanticColors(props);\n  const spaces = getSpaces(props);\n  const textOpenColor = hasInvertedStyle\n    ? semanticColors?.base.textPrimaryOnDark\n    : semanticColors?.base.textPrimary;\n\n  return css`\n    border-radius: 0;\n\n    &:hover {\n      background-color: ${hasInvertedStyle\n        ? semanticColors?.base?.backgroundPrimaryDark\n        : semanticColors?.base?.backgroundPrimary};\n    }\n\n    &[aria-expanded=\"true\"] {\n      position: sticky;\n      border-radius: 0;\n      top: calc(48px + ${spaces?.s}px);\n      z-index: 11;\n      backdrop-filter: blur(0px);\n      color: ${textOpenColor};\n      background-color: ${hasInvertedStyle\n        ? semanticColors?.base?.backgroundPrimaryDark\n        : semanticColors?.base?.backgroundPrimary};\n    }\n  `;\n};\n\nexport const StyledAccordion = styled(Accordion, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  padding: 0 !important;\n  width: 100%;\n  min-width: unset;\n\n  .MuiAccordionSummary-content {\n    ${fontBodyMediumL}\n  }\n\n  .MuiAccordionDetails-root .MuiButtonBase-root .primary-text {\n    ${fontBodyS}\n  }\n\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle, sdsStyle = \"dropdown\" } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n\n    const textDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.textSecondaryOnDark\n      : semanticColors?.base.textSecondary;\n\n    const textOpenColor = hasInvertedStyle\n      ? semanticColors?.base.textPrimaryOnDark\n      : semanticColors?.base.textPrimary;\n\n    const ChevronDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.ornamentSecondaryOnDark\n      : semanticColors?.base.ornamentSecondary;\n\n    const ChevronOpenColor = hasInvertedStyle\n      ? semanticColors?.base?.ornamentSecondaryPressedOnDark\n      : semanticColors?.base.ornamentSecondaryPressed;\n\n    return css`\n      & > .MuiButtonBase-root {\n        padding: ${spaces?.s}px ${spaces?.l}px !important;\n        border-radius: ${corners?.l}px;\n        color: ${textDefaultColor};\n\n        svg {\n          color: ${ChevronDefaultColor};\n        }\n\n        &[aria-expanded=\"true\"] {\n          position: sticky;\n          border-radius: ${corners?.l}px;\n          top: calc(48px + ${spaces?.s}px);\n          z-index: 11;\n          backdrop-filter: blur(8px);\n          color: ${textOpenColor};\n          background-color: ${hasInvertedStyle\n            ? semanticColors?.base?.fillPressedOnDark\n            : semanticColors?.base?.fillPressed};\n\n          &::before {\n            content: \"\";\n            position: absolute;\n            top: -${spaces?.s}px;\n            left: -${spaces?.l ?? 0 * 2}px;\n            right: -${spaces?.l ?? 0 * 2}px;\n            bottom: 0;\n            background-color: ${hasInvertedStyle\n              ? semanticColors?.base?.backgroundPrimaryDark\n              : semanticColors?.base?.backgroundPrimary};\n          }\n\n          &::after {\n            content: \"\";\n            position: absolute;\n            top: 100%;\n            left: 0;\n            width: 100%;\n            height: 10px;\n            background-image: linear-gradient(\n              to bottom,\n              ${hasInvertedStyle\n                ? semanticColors?.base?.backgroundPrimaryDark\n                : semanticColors?.base?.backgroundPrimary},\n              transparent\n            );\n          }\n\n          .MuiAccordionSummary-content {\n            ${fontBodySemiboldL(props)}\n            position: relative;\n            z-index: 12;\n          }\n\n          svg {\n            color: ${ChevronOpenColor} !important;\n          }\n        }\n\n        &:hover {\n          width: 100%;\n          box-shadow: none;\n          background: ${hasInvertedStyle\n            ? semanticColors?.base.fillHoverOnDark\n            : semanticColors?.base.fillHover};\n          color: ${hasInvertedStyle\n            ? semanticColors?.base.textPrimaryOnDark\n            : semanticColors?.base.textPrimary};\n\n          svg {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base?.ornamentSecondaryHoverOnDark\n              : semanticColors?.base.ornamentSecondaryHover} !important;\n          }\n        }\n\n        ${sdsStyle === \"drawer\" && DrawerAccordionStyles(props)}\n      }\n\n      .MuiCollapse-root .MuiAccordionDetails-root {\n        padding: 0;\n        margin-top: ${sdsStyle === \"drawer\" ? spaces?.s : spaces?.xxs}px;\n\n        .MuiButtonBase-root {\n          ${sdsStyle === \"drawer\"\n            ? css`\n                padding: ${spaces?.s}px 0;\n              `\n            : css`\n                padding: ${spaces?.s}px ${spaces?.m}px ${spaces?.s}px\n                  ${spaces?.xl}px !important;\n              `}\n\n          width: 100%;\n\n          svg {\n            color: ${semanticColors?.accent?.ornament};\n          }\n\n          .primary-text {\n            color: ${hasInvertedStyle\n              ? semanticColors?.base.textSecondaryOnDark\n              : semanticColors?.base.textSecondary} !important;\n          }\n\n          &:hover {\n            .primary-text {\n              color: ${hasInvertedStyle\n                ? semanticColors?.base.textPrimaryOnDark\n                : semanticColors?.base.textPrimary} !important;\n            }\n          }\n        }\n      }\n    `;\n  }}\n`;\n\ninterface StyledSectionDividerProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n}\n\nexport const StyledSectionDivider = styled(Divider, {\n  shouldForwardProp: (prop) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop as string),\n})`\n  ${(props: StyledSectionDividerProps) => {\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return `\n      margin: ${spaces?.s}px 0;\n      border-color: ${\n        props.hasInvertedStyle\n          ? semanticColors?.base.dividerOnDark\n          : semanticColors?.base.divider\n      };\n    `;\n  }}\n`;\n\n// Hover Drawer Components for sdsStyle=\"drawer\"\nexport const StyledMegaMenuDrawer = styled(Drawer, {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\", \"topOffset\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps & { topOffset?: number }) => {\n    const { hasInvertedStyle, topOffset = 0 } = props;\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      pointer-events: none;\n      top: ${topOffset}px;\n\n      .MuiDrawer-paper {\n        background-color: ${hasInvertedStyle\n          ? semanticColors?.base.backgroundPrimaryDark\n          : semanticColors?.base.backgroundPrimary};\n        height: auto;\n        max-height: calc(100vh - ${topOffset}px);\n        overflow: visible;\n        pointer-events: auto;\n        box-shadow: 0 8px 8px 0 rgba(0, 0, 0, 0.1);\n        background-image: none;\n        padding: ${spaces?.xl ? spaces?.xl + 48 : 48}px ${spaces?.xl}px\n          ${spaces?.xxl}px;\n        transform: translateY(48px);\n        top: ${topOffset}px;\n      }\n\n      .MuiBackdrop-root {\n        background-color: rgba(0, 0, 0, 0.05);\n        backdrop-filter: blur(2px);\n        top: ${topOffset}px;\n      }\n    `;\n  }}\n`;\n\nexport const StyledMegaMenuContent = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle } = props;\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      background-color: ${hasInvertedStyle\n        ? semanticColors?.base.backgroundPrimaryDark\n        : semanticColors?.base.backgroundPrimary};\n      display: flex;\n      flex-wrap: wrap;\n      gap: ${spaces?.xxl}px;\n      width: 100%;\n      max-width: 1200px;\n      margin: 0 auto;\n      justify-content: center;\n      transition: opacity 300ms ease-in-out;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerColumn = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\", \"totalColumns\"].includes(prop),\n})<ExtraHeaderProps & { totalColumns?: number }>`\n  ${(props: ExtraHeaderProps & { totalColumns?: number }) => {\n    const spaces = getSpaces(props);\n    const { totalColumns = 1 } = props;\n\n    // Calculate equal width for all columns based on total columns\n    // Account for gaps between columns\n    const columnsPerRow = totalColumns > 4 ? 4 : totalColumns;\n    const gapCount = columnsPerRow - 1;\n    const columnWidth = `calc((100% - (${gapCount} * ${spaces?.xxl}px)) / ${columnsPerRow})`;\n\n    return css`\n      display: flex;\n      flex-direction: column;\n      flex: 0 0 ${columnWidth};\n      min-width: 240px;\n      max-width: 400px;\n    `;\n  }}\n`;\n\nexport const StyledContentWrapper = styled(\"div\")<\n  CommonThemeProps & { needsHeaderPadding: boolean }\n>`\n  ${(props) => {\n    const { needsHeaderPadding } = props;\n\n    const spaces = getSpaces(props);\n    const typography = getTypography(props);\n\n    // Calculate padding to match header height + margin\n    // fontHeaderM has line-height of 22px, plus margin-bottom of m (12px)\n    const headerHeight = parseInt(\n      (typography?.wideStyles?.header?.semibold?.m?.lineHeight as string) ||\n        \"22px\"\n    );\n    const headerMargin = spaces?.m || 12;\n\n    return css`\n      & > *:last-child {\n        margin-bottom: 0;\n      }\n\n      padding-top: ${needsHeaderPadding ? headerHeight + headerMargin : 0}px;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerColumnHeader = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle } = props;\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      ${fontHeaderM(props)}\n      font-weight: 600;\n      color: ${hasInvertedStyle\n        ? semanticColors?.base.textSecondaryOnDark\n        : semanticColors?.base.textSecondary};\n      padding: 0 0 0 56px;\n      margin-bottom: ${spaces?.m}px;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItem = styled(\n  Button as unknown as React.ComponentType<\n    Partial<SdsMinimalButtonProps> &\n      ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }\n  >,\n  {\n    shouldForwardProp: (prop: string) =>\n      ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n  }\n)<ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }) => {\n    const { hasInvertedStyle, hasDetails } = props;\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n    const spaces = getSpaces(props);\n\n    return css`\n      border: none;\n      outline: none;\n      background: transparent;\n      box-shadow: none;\n      justify-content: flex-start;\n      text-align: left;\n      padding: ${spaces?.s}px ${spaces?.l}px;\n      margin-bottom: ${hasDetails ? spaces?.m : 0}px;\n      border-radius: ${corners?.xl}px;\n      min-height: auto;\n      width: 100%;\n      white-space: wrap;\n\n      &:hover {\n        border: none;\n        outline: none;\n        box-shadow: none;\n        cursor: pointer;\n        background: ${hasInvertedStyle\n          ? semanticColors?.base.fillHoverOnDark\n          : semanticColors?.base.fillHover};\n        svg {\n          color: ${semanticColors?.accent?.ornament};\n        }\n      }\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemContent = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps & { hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasDetails?: boolean }) => {\n    const spaces = getSpaces(props);\n\n    return css`\n      display: flex;\n      align-items: center;\n      gap: ${spaces?.l}px;\n      width: 100%;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemIcon = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasIcon?: boolean; hasDetails?: boolean }) => {\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n    const { hasDetails } = props;\n\n    return css`\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 0 ${hasDetails ? 0 : spaces?.xxs}px;\n      color: ${semanticColors?.accent?.ornament};\n\n      svg {\n        color: ${semanticColors?.accent?.ornament};\n      }\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemText = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${() => {\n    return css`\n      display: flex;\n      flex-direction: column;\n      gap: 2px;\n      flex: 1;\n      min-width: 0;\n    `;\n  }}\n`;\n\nexport const EmptyIcon = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})<ExtraHeaderProps & { hasDetails?: boolean }>`\n  ${(props: ExtraHeaderProps & { hasDetails?: boolean }) => {\n    const { hasDetails } = props;\n    const spaces = getSpaces(props);\n    const iconSize = getIconSizes(props);\n\n    return css`\n      width: ${hasDetails ? iconSize?.l?.width : iconSize?.s?.width}px;\n      height: ${hasDetails ? iconSize?.l?.height : iconSize?.s?.height}px;\n      padding: 0 ${hasDetails ? 0 : spaces?.xxs}px;\n      box-sizing: content-box;\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemTitle = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps & { hasDetails?: boolean }) => {\n    const { hasInvertedStyle, hasDetails } = props;\n    const semanticColors = getSemanticColors(props);\n\n    return css`\n      ${hasDetails ? fontBodySemiboldS(props) : fontBodyMediumS(props)}\n      color: ${hasInvertedStyle\n        ? semanticColors?.base.textPrimaryOnDark\n        : semanticColors?.base.textPrimary};\n\n      display: -webkit-box;\n      -webkit-box-orient: vertical;\n      -webkit-line-clamp: 2;\n      overflow: hidden;\n\n      ${StyledHoverDrawerItem}:hover & {\n        color: ${hasInvertedStyle\n          ? semanticColors?.base.textPrimaryOnDark\n          : semanticColors?.base.textPrimary};\n      }\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerItemDetails = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { hasInvertedStyle } = props;\n    const semanticColors = getSemanticColors(props);\n\n    return css`\n      ${fontBodyXs(props)}\n      display: -webkit-box;\n      -webkit-box-orient: vertical;\n      -webkit-line-clamp: 3;\n      overflow: hidden;\n      color: ${hasInvertedStyle\n        ? semanticColors?.base.textSecondaryOnDark\n        : semanticColors?.base.textSecondary};\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerActions = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  ${(props: CommonThemeProps & { isNarrow?: boolean }) => {\n    const spaces = getSpaces(props);\n    const { isNarrow } = props;\n\n    return css`\n      display: flex;\n      flex-direction: row;\n      gap: ${spaces?.xs}px;\n      margin-top: ${spaces?.m}px;\n      padding-left: ${isNarrow\n        ? `calc(${spaces?.l}px + ${spaces?.m}px)`\n        : `calc(${spaces?.xxl}px + ${spaces?.xs}px)`};\n      flex-wrap: wrap;\n    `;\n  }}\n`;\n\nexport const StyledButton = styled(Button)<ExtraButtonProps>`\n  ${(props) => {\n    const { hasInvertedStyle } = props;\n\n    const colors = getColors(props);\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n    const mode = getMode(props);\n\n    return css`\n      background-color: ${hasInvertedStyle\n        ? colors?.gray[\"700\"]\n        : mode === \"dark\"\n          ? colors?.gray[\"100\"]\n          : colors?.gray[\"200\"]};\n      width: fit-content !important;\n      padding: ${spaces?.s}px ${spaces?.m}px !important;\n      color: ${hasInvertedStyle\n        ? semanticColors?.base?.textPrimaryOnDark\n        : semanticColors?.base?.textPrimary};\n    `;\n  }}\n`;\n\nexport const StyledHoverDrawerContainer = styled(\"div\", {\n  shouldForwardProp: (prop: string) =>\n    ![...doNotForwardProps, \"sdsStyle\"].includes(prop),\n})`\n  position: relative;\n`;\n","import styled from \"@emotion/styled\";\nimport {\n  getSemanticColors,\n  getSpaces,\n  getCorners,\n  fontBodyMediumS,\n  fontBodySemiboldS,\n  fontBodySemiboldL,\n  fontBodyMediumL,\n  CommonThemeProps,\n} from \"src/core/styles\";\nimport { css, SerializedStyles } from \"@emotion/react\";\nimport Tag from \"src/core/Tag\";\nimport Button from \"src/core/Button\";\n\ninterface PrimaryNavItemProps extends CommonThemeProps {\n  hasInvertedStyle?: boolean;\n  isNarrow?: boolean;\n  active?: boolean;\n  itemType?: \"dropdown\" | \"text\";\n  innerSdsStyle?: \"drawer\" | \"dropdown\";\n}\n\nconst doNotForwardProps = [\n  \"active\",\n  \"hasInvertedStyle\",\n  \"isNarrow\",\n  \"hasSection\",\n  \"innerSdsStyle\",\n  \"defaultUrl\",\n  \"hasDetails\",\n  \"hasIcon\",\n  \"sectionProps\",\n];\n\nconst NarrowPrimaryNavItem = (props: PrimaryNavItemProps): SerializedStyles => {\n  const { active, hasInvertedStyle, innerSdsStyle } = props;\n\n  const spaces = getSpaces(props);\n  const semanticColors = getSemanticColors(props);\n  const corners = getCorners(props);\n\n  const ChevronHoverColor = hasInvertedStyle\n    ? semanticColors?.base?.ornamentSecondaryHoverOnDark\n    : semanticColors?.base.ornamentSecondaryHover;\n\n  return css`\n    border-radius: ${corners?.l}px;\n    justify-content: start;\n    padding: ${spaces?.s}px ${spaces?.l}px;\n    ${innerSdsStyle === \"drawer\"\n      ? css`\n          background-color: transparent !important;\n        `\n      : css`\n          background-color: ${active\n            ? hasInvertedStyle\n              ? semanticColors?.base?.fillPressedOnDark\n              : semanticColors?.base?.fillPressed\n            : \"transparent\"};\n        `}\n    width: 100%;\n\n    &:hover {\n      ${innerSdsStyle === \"drawer\"\n        ? css`\n            background: transparent !important;\n          `\n        : css`\n            background: ${hasInvertedStyle\n              ? semanticColors?.base.fillHoverOnDark\n              : semanticColors?.base.fillHover};\n          `}\n      box-shadow: none;\n\n      ${StyledLabel} {\n        color: ${hasInvertedStyle\n          ? semanticColors?.base.textPrimaryOnDark\n          : semanticColors?.base.textPrimary};\n      }\n\n      svg {\n        color: ${ChevronHoverColor} !important;\n      }\n    }\n  `;\n};\n\nexport const PrimaryNavItem = styled(Button, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})<PrimaryNavItemProps>`\n  display: flex;\n  align-items: center;\n  min-width: fit-content;\n\n  ${(props: PrimaryNavItemProps) => {\n    const { hasInvertedStyle, isNarrow, active } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n\n    const ChevronDefaultColor = hasInvertedStyle\n      ? semanticColors?.base.ornamentSecondaryOnDark\n      : semanticColors?.base.ornamentSecondary;\n\n    const ChevronHoverColor = hasInvertedStyle\n      ? semanticColors?.base?.ornamentSecondaryHoverOnDark\n      : semanticColors?.base.ornamentSecondaryHover;\n\n    const ChevronOpenColor = hasInvertedStyle\n      ? semanticColors?.base.ornamentSecondaryPressedOnDark\n      : semanticColors?.base.ornamentSecondaryPressed;\n\n    return css`\n      border: none;\n      padding: ${spaces?.xxxs}px ${spaces?.m}px;\n      border-radius: ${corners?.l}px;\n      background-color: ${active\n        ? hasInvertedStyle\n          ? semanticColors?.base?.fillPressedOnDark\n          : semanticColors?.base?.fillPressed\n        : \"transparent\"};\n\n      svg {\n        color: ${active ? ChevronOpenColor : ChevronDefaultColor};\n      }\n\n      &:hover {\n        background: ${hasInvertedStyle\n          ? semanticColors?.base.fillHoverOnDark\n          : semanticColors?.base.fillHover} !important;\n        box-shadow: none;\n\n        ${StyledLabel} {\n          color: ${hasInvertedStyle\n            ? semanticColors?.base.textPrimaryOnDark\n            : semanticColors?.base.textPrimary};\n        }\n\n        svg {\n          color: ${ChevronHoverColor} !important;\n        }\n      }\n\n      ${isNarrow && NarrowPrimaryNavItem(props)}\n    `;\n  }}\n`;\n\nexport const StyledTag = styled(Tag)`\n  margin: 0;\n`;\n\nexport const NarrowStyledLabel = (\n  props: PrimaryNavItemProps\n): SerializedStyles => {\n  const { active } = props;\n  return css`\n    ${active ? fontBodySemiboldL(props) : fontBodyMediumL(props)}\n  `;\n};\n\nexport const StyledLabel = styled(\"span\", {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: PrimaryNavItemProps) => {\n    const { hasInvertedStyle, active, isNarrow } = props;\n\n    const spaces = getSpaces(props);\n    const colors = getSemanticColors(props);\n\n    const activeColor = hasInvertedStyle\n      ? colors?.base.textPrimaryOnDark\n      : colors?.base.textPrimary;\n\n    const inactiveColor = hasInvertedStyle\n      ? colors?.base.textSecondaryOnDark\n      : colors?.base.textSecondary;\n\n    return [\n      active ? fontBodySemiboldS(props) : fontBodyMediumS(props),\n      css`\n        position: relative;\n        display: flex;\n        align-items: center;\n        gap: ${spaces?.xs}px;\n        color: ${active ? activeColor : inactiveColor};\n\n        /* TODO: Double check with Connor! */\n        /* ${StyledTag} {\n           margin-right: -${spaces?.s}px;margin-right\n        } */\n\n        ${isNarrow && NarrowStyledLabel(props)}\n      `,\n    ];\n  }}\n`;\n","import styled from \"@emotion/styled\";\nimport {\n  CommonThemeProps,\n  fontBodyMediumL,\n  fontBodyMediumS,\n  fontBodySemiboldM,\n  fontBodySemiboldL,\n  fontBodySemiboldS,\n  fontCapsXxxxs,\n  getSemanticColors,\n  getSpaces,\n  getCorners,\n} from \"src/core/styles\";\nimport { css, SerializedStyles } from \"@emotion/react\";\nimport ListSubheader from \"src/core/List/components/ListSubheader\";\nimport { Divider } from \"@mui/material\";\nimport { ExtraHeaderProps } from \"../style\";\nimport { AccordionDetails } from \"src/core/Accordion\";\n\nconst doNotForwardProps = [\n  \"isNarrow\",\n  \"hasSection\",\n  \"hasInvertedStyle\",\n  \"sectionProps\",\n  \"sdsStyle\",\n];\n\nconst NarrowStyledSection = (props: CommonThemeProps): SerializedStyles => {\n  const spaces = getSpaces(props);\n\n  return css`\n    align-items: start;\n    flex-direction: column;\n    margin-top: ${spaces?.m}px;\n  `;\n};\n\nexport const StyledSection = styled(\"section\", {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  display: flex;\n  align-items: center;\n\n  ${(props: CommonThemeProps & { isNarrow?: boolean }) => {\n    const { isNarrow } = props;\n    const spaces = getSpaces(props);\n\n    return css`\n      column-gap: ${spaces?.m}px;\n      row-gap: ${spaces?.s}px;\n      ${isNarrow && NarrowStyledSection(props)}\n    `;\n  }}\n`;\n\nexport const StyledSectionHeader = styled(ListSubheader, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: ExtraHeaderProps) => {\n    const { isNarrow, hasInvertedStyle, sdsStyle } = props;\n\n    const semanticColors = getSemanticColors(props);\n    const spaces = getSpaces(props);\n\n    function getBackgroundColor() {\n      if (isNarrow) {\n        return hasInvertedStyle\n          ? semanticColors?.base.backgroundPrimaryDark\n          : semanticColors?.base.backgroundPrimary;\n      }\n\n      return semanticColors?.base?.surface;\n    }\n\n    function getTextColor() {\n      if (isNarrow) {\n        return hasInvertedStyle\n          ? semanticColors?.base.textSecondaryOnDark\n          : semanticColors?.base.textSecondary;\n      }\n\n      return semanticColors?.base?.textSecondary;\n    }\n\n    if (sdsStyle === \"drawer\") {\n      return css`\n        ${fontBodySemiboldM(props)}\n        top: 0;\n        color: ${getTextColor()} !important;\n        background-color: transparent;\n        padding: 0;\n        margin-bottom: ${spaces?.xxs}px !important;\n      `;\n    }\n\n    return css`\n      &.MuiListSubheader-root {\n        ${fontCapsXxxxs(props)}\n        top: 0;\n        color: ${getTextColor()};\n        background-color: ${getBackgroundColor()};\n        padding: ${spaces?.xxs}px ${isNarrow ? spaces?.xl : spaces?.xs}px;\n        margin-bottom: 0;\n      }\n    `;\n  }}\n`;\n\nexport const StyledAccordionDetails = styled(AccordionDetails, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: CommonThemeProps & { sdsStyle?: \"dropdown\" | \"drawer\" }) => {\n    const { sdsStyle } = props;\n    const spaces = getSpaces(props);\n\n    return css`\n      ${sdsStyle === \"drawer\" &&\n      css`\n        display: flex;\n        flex-direction: column;\n        gap: ${spaces?.m}px;\n      `}\n    `;\n  }}\n`;\n\nexport const StyledAccordionSection = styled(\"div\", {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(\n    props: CommonThemeProps & {\n      sdsStyle?: \"dropdown\" | \"drawer\";\n      hasInvertedStyle?: boolean;\n    }\n  ) => {\n    const { sdsStyle, hasInvertedStyle } = props;\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n    const corners = getCorners(props);\n\n    if (sdsStyle === \"drawer\") {\n      return css`\n        border-radius: ${corners?.xl}px;\n        padding: ${spaces?.l}px;\n        background-color: ${hasInvertedStyle\n          ? semanticColors?.base?.backgroundSecondaryOnDark\n          : semanticColors?.base?.backgroundSecondary};\n      `;\n    }\n\n    return css`\n      padding: 0;\n    `;\n  }}\n`;\n\ninterface StyledDividerProps extends CommonThemeProps {\n  hasSection?: boolean;\n  isNarrow?: boolean;\n  hasInvertedStyle?: boolean;\n}\n\nexport const StyledDivider = styled(Divider, {\n  shouldForwardProp: (prop: string) => !doNotForwardProps.includes(prop),\n})`\n  ${(props: StyledDividerProps) => {\n    const { hasSection, isNarrow, hasInvertedStyle } = props;\n\n    const spaces = getSpaces(props);\n    const semanticColors = getSemanticColors(props);\n\n    // Calculate margin based on section and narrow state\n    const getMarginBottom = () => {\n      return hasSection ? spaces?.s : spaces?.xxs;\n    };\n\n    const getBorderColor = () => {\n      if (isNarrow) {\n        return hasInvertedStyle\n          ? semanticColors?.base?.dividerOnDark\n          : semanticColors?.base?.divider;\n      }\n\n      return semanticColors?.base?.divider;\n    };\n\n    return css`\n      &.MuiDivider-root {\n        position: relative;\n        margin: 0 0 ${getMarginBottom()}px;\n        border-bottom: solid 1px ${getBorderColor()};\n        padding-bottom: ${spaces?.xxs}px;\n      }\n    `;\n  }}\n`;\n\nexport const StyledLabelTextWrapper = styled(\"div\")`\n  ${(props: CommonThemeProps & { active?: boolean; isNarrow?: boolean }) => {\n    const { active, isNarrow } = props;\n\n    return [\n      isNarrow\n        ? active\n          ? fontBodySemiboldL(props)\n          : fontBodyMediumL(props)\n        : active\n          ? fontBodySemiboldS(props)\n          : fontBodyMediumS(props),\n      css`\n        position: absolute;\n      `,\n    ];\n  }}\n`;\n\nexport const StyledLabelTextWrapperShadow = styled(\"div\")`\n  ${(props: CommonThemeProps & { active?: boolean; isNarrow?: boolean }) => {\n    const { isNarrow } = props;\n    return css`\n      ${isNarrow ? fontBodySemiboldL(props) : fontBodySemiboldS(props)}\n      visibility: hidden;\n      opacity: 0;\n    `;\n  }}\n`;\n","import { AppBarProps, css, useScrollTrigger, useTheme } from \"@mui/material\";\nimport React from \"react\";\nimport { CommonThemeProps } from \"src/core/styles\";\n\ninterface ElevationScrollProps extends CommonThemeProps, AppBarProps {\n  window?: () => Window;\n  children?: React.ReactElement;\n  shouldElevate?: boolean;\n}\n\nfunction ElevationScroll(elevationProps: ElevationScrollProps) {\n  const { children, window, shouldElevate = true } = elevationProps;\n  const theme = useTheme();\n  const mode = theme.palette.mode;\n\n  const trigger = useScrollTrigger({\n    disableHysteresis: true,\n    target: window ? window() : undefined,\n    threshold: 0,\n  });\n\n  const darkModeStyles = css`\n    border-bottom: 1px solid ${theme.palette?.sds?.base?.borderSecondary};\n  `;\n\n  /**\n   * (masoudmanson): Elevation is set to 10 when the user scrolls and 0 otherwise.\n   * MUI's elevation range is 0-24, but in the SDS theme, we have mapped:\n   * - shadow.none to 0\n   * - shadow.S to values 1-8\n   * - shadow.M to values 9-16\n   * - shadow.L to values 17-24\n   *\n   * Since the navigation requires a shadow.M drop shadow based on the design system,\n   * any elevation value between 9 and 16 will produce the same effect.\n   */\n  return children\n    ? React.cloneElement(children, {\n        elevation: trigger && shouldElevate ? 14 : 0,\n        sx:\n          trigger && shouldElevate\n            ? {\n                ...(elevationProps.sx || {}),\n                ...(mode === \"dark\" && darkModeStyles),\n              }\n            : undefined,\n      })\n    : null;\n}\n\nexport default ElevationScroll;\n"],"names":[],"sourceRoot":""}